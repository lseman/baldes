<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BALDES: SCC Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BALDES
   </div>
   <div id="projectbrief">Bucket Graph Labeling Algorithm for Vehicle Routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classSCC.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSCC-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SCC Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class to find Strongly Connected Components (SCCs) in a directed graph using Tarjan's algorithm.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae04359df6e5695307f48667b5cc8bca9" id="r_ae04359df6e5695307f48667b5cc8bca9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae04359df6e5695307f48667b5cc8bca9">SCC</a> ()</td></tr>
<tr class="separator:ae04359df6e5695307f48667b5cc8bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9aaadeeda1e882c033db0fed40d548" id="r_a8c9aaadeeda1e882c033db0fed40d548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9aaadeeda1e882c033db0fed40d548">addEdge</a> (int v, int w)</td></tr>
<tr class="memdesc:a8c9aaadeeda1e882c033db0fed40d548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge from vertex v to vertex w in the graph.  <br /></td></tr>
<tr class="separator:a8c9aaadeeda1e882c033db0fed40d548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c0a300e9234ccf344072b1f2c949b" id="r_a1c3c0a300e9234ccf344072b1f2c949b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c3c0a300e9234ccf344072b1f2c949b">convertFromUnorderedMap</a> (const ankerl::unordered_dense::map&lt; int, std::vector&lt; int &gt; &gt; &amp;map)</td></tr>
<tr class="memdesc:a1c3c0a300e9234ccf344072b1f2c949b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unordered map representation of a graph into an internal graph representation.  <br /></td></tr>
<tr class="separator:a1c3c0a300e9234ccf344072b1f2c949b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc7bf9b9ebc6853227b86fe4cb151ea" id="r_afdc7bf9b9ebc6853227b86fe4cb151ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc7bf9b9ebc6853227b86fe4cb151ea">tarjanSCC</a> ()</td></tr>
<tr class="memdesc:afdc7bf9b9ebc6853227b86fe4cb151ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns all Strongly Connected Components (SCCs) in the graph using Tarjan's algorithm.  <br /></td></tr>
<tr class="separator:afdc7bf9b9ebc6853227b86fe4cb151ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62703561fe2b0e0a6f7961b09778ff6e" id="r_a62703561fe2b0e0a6f7961b09778ff6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62703561fe2b0e0a6f7961b09778ff6e">topologicalOrderOfSCCs</a> (const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;sccs)</td></tr>
<tr class="memdesc:a62703561fe2b0e0a6f7961b09778ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the topological order of Strongly Connected Components (SCCs) in a directed graph.  <br /></td></tr>
<tr class="separator:a62703561fe2b0e0a6f7961b09778ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e3e2a990c029246c02689742ba915c" id="r_a78e3e2a990c029246c02689742ba915c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e3e2a990c029246c02689742ba915c">exportToDot</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;sccs)</td></tr>
<tr class="memdesc:a78e3e2a990c029246c02689742ba915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the strongly connected components (SCCs) of a graph to a DOT file.  <br /></td></tr>
<tr class="separator:a78e3e2a990c029246c02689742ba915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to find Strongly Connected Components (SCCs) in a directed graph using Tarjan's algorithm. </p>
<p>This class provides methods to add edges to the graph, convert from an unordered map representation, find SCCs using Tarjan's algorithm, determine the topological order of SCCs, and export the graph to a DOT file. </p>

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00026">26</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae04359df6e5695307f48667b5cc8bca9" name="ae04359df6e5695307f48667b5cc8bca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04359df6e5695307f48667b5cc8bca9">&#9670;&#160;</a></span>SCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SCC::SCC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00028">28</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   28</span>: currentIndex(0) {}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c9aaadeeda1e882c033db0fed40d548" name="a8c9aaadeeda1e882c033db0fed40d548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9aaadeeda1e882c033db0fed40d548">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCC::addEdge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directed edge from vertex v to vertex w in the graph. </p>
<p>This function ensures that the adjacency list and other related structures are resized appropriately if the vertices v or w exceed the current size. It then adds w to the adjacency list of v. </p>

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00038">38</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   38</span>                               {</div>
<div class="line"><span class="lineno">   39</span>        <span class="keywordflow">if</span> (v &gt;= adj.size() || w &gt;= adj.size()) {</div>
<div class="line"><span class="lineno">   40</span>            <span class="keywordtype">int</span> newSize = std::max(v, w) + 1;</div>
<div class="line"><span class="lineno">   41</span>            adj.resize(newSize);</div>
<div class="line"><span class="lineno">   42</span>            index.resize(newSize, -1);</div>
<div class="line"><span class="lineno">   43</span>            lowlink.resize(newSize, -1);</div>
<div class="line"><span class="lineno">   44</span>            onStack.resize(newSize, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">   45</span>        }</div>
<div class="line"><span class="lineno">   46</span>        adj[v].push_back(w);</div>
<div class="line"><span class="lineno">   47</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c3c0a300e9234ccf344072b1f2c949b" name="a1c3c0a300e9234ccf344072b1f2c949b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3c0a300e9234ccf344072b1f2c949b">&#9670;&#160;</a></span>convertFromUnorderedMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCC::convertFromUnorderedMap </td>
          <td>(</td>
          <td class="paramtype">const ankerl::unordered_dense::map&lt; int, std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unordered map representation of a graph into an internal graph representation. </p>
<p>This function takes an unordered map where the keys are vertex identifiers and the values are vectors of adjacent vertices. It iterates through the map and adds edges to the internal graph representation using the addEdge function. </p>

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00057">57</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   57</span>                                                                                           {</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : map) {</div>
<div class="line"><span class="lineno">   59</span>            <span class="keywordtype">int</span> v = pair.first;</div>
<div class="line"><span class="lineno">   60</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> w : pair.second) { <a class="code hl_function" href="#a8c9aaadeeda1e882c033db0fed40d548">addEdge</a>(v, w); }</div>
<div class="line"><span class="lineno">   61</span>        }</div>
<div class="line"><span class="lineno">   62</span>    }</div>
<div class="ttc" id="aclassSCC_html_a8c9aaadeeda1e882c033db0fed40d548"><div class="ttname"><a href="#a8c9aaadeeda1e882c033db0fed40d548">SCC::addEdge</a></div><div class="ttdeci">void addEdge(int v, int w)</div><div class="ttdoc">Adds a directed edge from vertex v to vertex w in the graph.</div><div class="ttdef"><b>Definition</b> <a href="SCCFinder_8h_source.html#l00038">SCCFinder.h:38</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSCC_a1c3c0a300e9234ccf344072b1f2c949b_cgraph.png" border="0" usemap="#aclassSCC_a1c3c0a300e9234ccf344072b1f2c949b_cgraph" alt=""/></div>
<map name="aclassSCC_a1c3c0a300e9234ccf344072b1f2c949b_cgraph" id="aclassSCC_a1c3c0a300e9234ccf344072b1f2c949b_cgraph">
<area shape="rect" title="Converts an unordered map representation of a graph into an internal graph representation." alt="" coords="5,5,218,31"/>
<area shape="rect" href="classSCC.html#a8c9aaadeeda1e882c033db0fed40d548" title="Adds a directed edge from vertex v to vertex w in the graph." alt="" coords="266,5,370,31"/>
<area shape="poly" title=" " alt="" coords="218,16,250,16,250,21,218,21"/>
</map>
</div>

</div>
</div>
<a id="a78e3e2a990c029246c02689742ba915c" name="a78e3e2a990c029246c02689742ba915c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e3e2a990c029246c02689742ba915c">&#9670;&#160;</a></span>exportToDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCC::exportToDot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sccs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exports the strongly connected components (SCCs) of a graph to a DOT file. </p>
<p>This function generates a DOT file representing the graph with nodes colored according to their <a class="el" href="classSCC.html" title="A class to find Strongly Connected Components (SCCs) in a directed graph using Tarjan&#39;s algorithm.">SCC</a>. Each <a class="el" href="classSCC.html" title="A class to find Strongly Connected Components (SCCs) in a directed graph using Tarjan&#39;s algorithm.">SCC</a> is assigned a different color from a predefined set of colors. </p>

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00137">137</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  137</span>                                                                                       {</div>
<div class="line"><span class="lineno">  138</span>        std::ofstream dotFile(filename);</div>
<div class="line"><span class="lineno">  139</span>        <span class="keywordflow">if</span> (!dotFile.is_open()) {</div>
<div class="line"><span class="lineno">  140</span>            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Could not open file for writing\n&quot;</span>;</div>
<div class="line"><span class="lineno">  141</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  142</span>        }</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>        <span class="comment">// Start DOT file format</span></div>
<div class="line"><span class="lineno">  145</span>        dotFile &lt;&lt; <span class="stringliteral">&quot;digraph G {\n&quot;</span>;</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>        <span class="comment">// Assign each SCC a different color</span></div>
<div class="line"><span class="lineno">  148</span>        std::vector&lt;std::string&gt; colors = {<span class="stringliteral">&quot;red&quot;</span>,    <span class="stringliteral">&quot;green&quot;</span>, <span class="stringliteral">&quot;blue&quot;</span>,    <span class="stringliteral">&quot;yellow&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>,</div>
<div class="line"><span class="lineno">  149</span>                                           <span class="stringliteral">&quot;purple&quot;</span>, <span class="stringliteral">&quot;cyan&quot;</span>,  <span class="stringliteral">&quot;magenta&quot;</span>, <span class="stringliteral">&quot;lime&quot;</span>,   <span class="stringliteral">&quot;pink&quot;</span>};</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>        <span class="comment">// Create a mapping from node to SCC index</span></div>
<div class="line"><span class="lineno">  152</span>        ankerl::unordered_dense::map&lt;int, int&gt; nodeToScc;</div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sccs.size(); ++i) {</div>
<div class="line"><span class="lineno">  154</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node : sccs[i]) { nodeToScc[node] = i; }</div>
<div class="line"><span class="lineno">  155</span>        }</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>        <span class="comment">// Output nodes with their SCC colors</span></div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; adj.size(); ++v) {</div>
<div class="line"><span class="lineno">  159</span>            std::string color = colors[nodeToScc[v] % colors.size()];</div>
<div class="line"><span class="lineno">  160</span>            dotFile &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; [style=filled, fillcolor=\&quot;&quot;</span> &lt;&lt; color &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;</div>
<div class="line"><span class="lineno">  161</span>        }</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>        <span class="comment">// Output edges</span></div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; adj.size(); ++v) {</div>
<div class="line"><span class="lineno">  165</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> w : adj[v]) { dotFile &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; w &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>; }</div>
<div class="line"><span class="lineno">  166</span>        }</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>        <span class="comment">// End DOT file format</span></div>
<div class="line"><span class="lineno">  169</span>        dotFile &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  170</span>        dotFile.close();</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Graph exported to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  173</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afdc7bf9b9ebc6853227b86fe4cb151ea" name="afdc7bf9b9ebc6853227b86fe4cb151ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc7bf9b9ebc6853227b86fe4cb151ea">&#9670;&#160;</a></span>tarjanSCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; SCC::tarjanSCC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns all Strongly Connected Components (SCCs) in the graph using Tarjan's algorithm. </p>
<p>This function implements Tarjan's algorithm to find all SCCs in a directed graph. It iterates over all vertices and applies the strongConnect function to each vertex that has not been visited yet (indicated by an index of -1). The result is a vector of SCCs, where each <a class="el" href="classSCC.html" title="A class to find Strongly Connected Components (SCCs) in a directed graph using Tarjan&#39;s algorithm.">SCC</a> is represented as a vector of vertex indices. </p>

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00072">72</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   72</span>                                          {</div>
<div class="line"><span class="lineno">   73</span>        std::vector&lt;std::vector&lt;int&gt;&gt; sccs;</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; adj.size(); ++v) {</div>
<div class="line"><span class="lineno">   76</span>            <span class="keywordflow">if</span> (index[v] == -1) { strongConnect(v, sccs); }</div>
<div class="line"><span class="lineno">   77</span>        }</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>        <span class="keywordflow">return</span> sccs;</div>
<div class="line"><span class="lineno">   80</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a62703561fe2b0e0a6f7961b09778ff6e" name="a62703561fe2b0e0a6f7961b09778ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62703561fe2b0e0a6f7961b09778ff6e">&#9670;&#160;</a></span>topologicalOrderOfSCCs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; SCC::topologicalOrderOfSCCs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sccs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the topological order of Strongly Connected Components (SCCs) in a directed graph. </p>
<p>This function takes a list of SCCs and computes a topological ordering of these components. The input is a vector of vectors, where each inner vector represents a <a class="el" href="classSCC.html" title="A class to find Strongly Connected Components (SCCs) in a directed graph using Tarjan&#39;s algorithm.">SCC</a> containing node indices. </p>

<p class="definition">Definition at line <a class="el" href="SCCFinder_8h_source.html#l00089">89</a> of file <a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   89</span>                                                                                 {</div>
<div class="line"><span class="lineno">   90</span>        ankerl::unordered_dense::map&lt;int, int&gt; nodeToScc;</div>
<div class="line"><span class="lineno">   91</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sccs.size(); ++i) {</div>
<div class="line"><span class="lineno">   92</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node : sccs[i]) { nodeToScc[node] = i; }</div>
<div class="line"><span class="lineno">   93</span>        }</div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span>        std::vector&lt;ankerl::unordered_dense::set&lt;int&gt;&gt; componentGraph(sccs.size());</div>
<div class="line"><span class="lineno">   96</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; adj.size(); ++v) {</div>
<div class="line"><span class="lineno">   97</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> w : adj[v]) {</div>
<div class="line"><span class="lineno">   98</span>                <span class="keywordtype">int</span> sccV = nodeToScc[v];</div>
<div class="line"><span class="lineno">   99</span>                <span class="keywordtype">int</span> sccW = nodeToScc[w];</div>
<div class="line"><span class="lineno">  100</span>                <span class="keywordflow">if</span> (sccV != sccW) { componentGraph[sccV].insert(sccW); }</div>
<div class="line"><span class="lineno">  101</span>            }</div>
<div class="line"><span class="lineno">  102</span>        }</div>
<div class="line"><span class="lineno">  103</span> </div>
<div class="line"><span class="lineno">  104</span>        std::vector&lt;int&gt; inDegree(sccs.size(), 0);</div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;neighbors : componentGraph) {</div>
<div class="line"><span class="lineno">  106</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> neighbor : neighbors) { ++inDegree[neighbor]; }</div>
<div class="line"><span class="lineno">  107</span>        }</div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>        std::stack&lt;int&gt; zeroInDegreeNodes;</div>
<div class="line"><span class="lineno">  110</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; inDegree.size(); ++i) {</div>
<div class="line"><span class="lineno">  111</span>            <span class="keywordflow">if</span> (inDegree[i] == 0) { zeroInDegreeNodes.push(i); }</div>
<div class="line"><span class="lineno">  112</span>        }</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>        std::vector&lt;int&gt; topologicalOrder;</div>
<div class="line"><span class="lineno">  115</span>        <span class="keywordflow">while</span> (!zeroInDegreeNodes.empty()) {</div>
<div class="line"><span class="lineno">  116</span>            <span class="keywordtype">int</span> node = zeroInDegreeNodes.top();</div>
<div class="line"><span class="lineno">  117</span>            zeroInDegreeNodes.pop();</div>
<div class="line"><span class="lineno">  118</span>            topologicalOrder.push_back(node);</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> neighbor : componentGraph[node]) {</div>
<div class="line"><span class="lineno">  121</span>                --inDegree[neighbor];</div>
<div class="line"><span class="lineno">  122</span>                <span class="keywordflow">if</span> (inDegree[neighbor] == 0) { zeroInDegreeNodes.push(neighbor); }</div>
<div class="line"><span class="lineno">  123</span>            }</div>
<div class="line"><span class="lineno">  124</span>        }</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>        <span class="keywordflow">return</span> topologicalOrder;</div>
<div class="line"><span class="lineno">  127</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SCCFinder_8h_source.html">SCCFinder.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSCC.html">SCC</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
