<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BALDES: IteratedLocalSearch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BALDES
   </div>
   <div id="projectbrief">Bucket Graph Labeling Algorithm for Vehicle Routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classIteratedLocalSearch.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classIteratedLocalSearch-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IteratedLocalSearch Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RIH_8h_source.html">RIH.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for IteratedLocalSearch:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch__coll__graph.png" border="0" usemap="#aIteratedLocalSearch_coll__map" alt="Collaboration graph"/></div>
<map name="aIteratedLocalSearch_coll__map" id="aIteratedLocalSearch_coll__map">
<area shape="rect" title=" " alt="" coords="101,183,240,208"/>
<area shape="rect" href="structInstanceData.html" title="A structure to hold various data related to an instance of a problem." alt="" coords="5,94,104,120"/>
<area shape="poly" title=" " alt="" coords="80,128,115,157,151,180,148,184,112,161,76,132"/>
<area shape="rect" href="classCutStorage.html" title="Manages the storage and operations related to cuts in a solver." alt="" coords="127,94,214,120"/>
<area shape="poly" title=" " alt="" coords="173,135,173,182,168,182,168,135"/>
<area shape="rect" href="structCutStorage_1_1SegmentMasks.html" title=" " alt="" coords="79,5,262,31"/>
<area shape="poly" title=" " alt="" coords="173,47,173,94,168,94,168,47"/>
<area shape="rect" href="classXoroshiro128Plus.html" title=" " alt="" coords="238,94,362,120"/>
<area shape="poly" title=" " alt="" coords="281,133,248,161,203,184,201,180,245,156,277,129"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae2fa6e2669be463de56ce1fd34cf3684" id="r_ae2fa6e2669be463de56ce1fd34cf3684"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2fa6e2669be463de56ce1fd34cf3684">OperatorFunc</a></td></tr>
<tr class="separator:ae2fa6e2669be463de56ce1fd34cf3684"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5139ace2f7924ec0838aadf2051d6533" id="r_a5139ace2f7924ec0838aadf2051d6533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5139ace2f7924ec0838aadf2051d6533">IteratedLocalSearch</a> (const <a class="el" href="structInstanceData.html">InstanceData</a> &amp;<a class="el" href="#a75465311932a906c7e891d960af07f3a">instance</a>)</td></tr>
<tr class="separator:a5139ace2f7924ec0838aadf2051d6533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c703d2dcdc3b1f88f2012451e8f3bc" id="r_a54c703d2dcdc3b1f88f2012451e8f3bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54c703d2dcdc3b1f88f2012451e8f3bc">~IteratedLocalSearch</a> ()</td></tr>
<tr class="separator:a54c703d2dcdc3b1f88f2012451e8f3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac407b2b6df160cc5783c5e2f48c095ae" id="r_ac407b2b6df160cc5783c5e2f48c095ae"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac407b2b6df160cc5783c5e2f48c095ae">srex_crossover</a> (const std::vector&lt; uint16_t &gt; &amp;parent1, const std::vector&lt; uint16_t &gt; &amp;parent2, int i, int j)</td></tr>
<tr class="separator:ac407b2b6df160cc5783c5e2f48c095ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae8f4d483cf54d105d1578642b86a66" id="r_adae8f4d483cf54d105d1578642b86a66"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae8f4d483cf54d105d1578642b86a66">relocate_star</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</td></tr>
<tr class="memdesc:adae8f4d483cf54d105d1578642b86a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocates a customer from one route to another.  <br /></td></tr>
<tr class="separator:adae8f4d483cf54d105d1578642b86a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55d7fcdce5a31d6805b71942ca039e1" id="r_aa55d7fcdce5a31d6805b71942ca039e1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55d7fcdce5a31d6805b71942ca039e1">enhanced_swap</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</td></tr>
<tr class="memdesc:aa55d7fcdce5a31d6805b71942ca039e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps segments of varying lengths between two routes.  <br /></td></tr>
<tr class="separator:aa55d7fcdce5a31d6805b71942ca039e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e952673bf5b27eb6491d7a24eab2b8" id="r_a51e952673bf5b27eb6491d7a24eab2b8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e952673bf5b27eb6491d7a24eab2b8">cross</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</td></tr>
<tr class="memdesc:a51e952673bf5b27eb6491d7a24eab2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a crossover operation between two routes at specified positions.  <br /></td></tr>
<tr class="separator:a51e952673bf5b27eb6491d7a24eab2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50de1ef7dc5a829711ed08667d75161f" id="r_a50de1ef7dc5a829711ed08667d75161f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50de1ef7dc5a829711ed08667d75161f">insertion</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</td></tr>
<tr class="memdesc:a50de1ef7dc5a829711ed08667d75161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a customer from one route into another route at specified positions.  <br /></td></tr>
<tr class="separator:a50de1ef7dc5a829711ed08667d75161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573128d044c04146324e6abb05ad4fb9" id="r_a573128d044c04146324e6abb05ad4fb9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573128d044c04146324e6abb05ad4fb9">swap</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</td></tr>
<tr class="memdesc:a573128d044c04146324e6abb05ad4fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps customers between two routes at specified positions.  <br /></td></tr>
<tr class="separator:a573128d044c04146324e6abb05ad4fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2b3dd4e5bc9b112f765455ba1d2fda" id="r_a4f2b3dd4e5bc9b112f765455ba1d2fda"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f2b3dd4e5bc9b112f765455ba1d2fda">nm_exchange</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</td></tr>
<tr class="separator:a4f2b3dd4e5bc9b112f765455ba1d2fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428b3f95156f560faf7eba8f398b4894" id="r_a428b3f95156f560faf7eba8f398b4894"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a428b3f95156f560faf7eba8f398b4894">nm_exchange_fun</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j, int n=2, int m=1)</td></tr>
<tr class="separator:a428b3f95156f560faf7eba8f398b4894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fdc6d03b30abfb18bd90a0240f8a34" id="r_ae4fdc6d03b30abfb18bd90a0240f8a34"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4fdc6d03b30abfb18bd90a0240f8a34">move_two_clients_reversed</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</td></tr>
<tr class="separator:ae4fdc6d03b30abfb18bd90a0240f8a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765ead85470b515f70b3795548f2fe0c" id="r_a765ead85470b515f70b3795548f2fe0c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a765ead85470b515f70b3795548f2fe0c">extended_swap_star</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</td></tr>
<tr class="memdesc:a765ead85470b515f70b3795548f2fe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps sequences of customers between two routes and inserts them at optimal positions.  <br /></td></tr>
<tr class="separator:a765ead85470b515f70b3795548f2fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c19f98bcafced3fb5c662687878d96" id="r_a54c19f98bcafced3fb5c662687878d96"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54c19f98bcafced3fb5c662687878d96">extended_swap_star_fun</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j, int chain_length=2)</td></tr>
<tr class="separator:a54c19f98bcafced3fb5c662687878d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c668d676ee2fc23b820b54088412925" id="r_a6c668d676ee2fc23b820b54088412925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c668d676ee2fc23b820b54088412925">find_best_insertion_position</a> (const std::vector&lt; uint16_t &gt; &amp;route, const std::vector&lt; uint16_t &gt; &amp;chain)</td></tr>
<tr class="memdesc:a6c668d676ee2fc23b820b54088412925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best position to insert a chain of customers into a route.  <br /></td></tr>
<tr class="separator:a6c668d676ee2fc23b820b54088412925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a385fcceeeac471cab42d124f7f4dae" id="r_a3a385fcceeeac471cab42d124f7f4dae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a385fcceeeac471cab42d124f7f4dae">compute_insertion_cost</a> (const std::vector&lt; uint16_t &gt; &amp;route, const std::vector&lt; uint16_t &gt; &amp;chain, int pos, double original_cost)</td></tr>
<tr class="separator:a3a385fcceeeac471cab42d124f7f4dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac035fef647f1bfd845ad6efa45f1ada6" id="r_ac035fef647f1bfd845ad6efa45f1ada6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac035fef647f1bfd845ad6efa45f1ada6">extended_relocate_star</a> (const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j, int chain_length=2)</td></tr>
<tr class="memdesc:ac035fef647f1bfd845ad6efa45f1ada6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocates a sequence of customers from one route to another.  <br /></td></tr>
<tr class="separator:ac035fef647f1bfd845ad6efa45f1ada6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0537178b1dabf661440b847b8b87f7e8" id="r_a0537178b1dabf661440b847b8b87f7e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0537178b1dabf661440b847b8b87f7e8">select_operator</a> (<a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> &amp;<a class="el" href="#a0736d613aa45e64be75d3220d2d1e678">rng</a>)</td></tr>
<tr class="separator:a0537178b1dabf661440b847b8b87f7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab6b57e4edf8ee77d1fc8872eef68d6" id="r_abab6b57e4edf8ee77d1fc8872eef68d6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab6b57e4edf8ee77d1fc8872eef68d6">apply_operator</a> (int op_index, const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</td></tr>
<tr class="separator:abab6b57e4edf8ee77d1fc8872eef68d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cbc1c0cb18d27433f706b51628dbdf" id="r_a03cbc1c0cb18d27433f706b51628dbdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03cbc1c0cb18d27433f706b51628dbdf">update_operator_weights</a> (double decay_factor=0.9, double reward_factor=0.1, double min_weight=0.01)</td></tr>
<tr class="separator:a03cbc1c0cb18d27433f706b51628dbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af273ca9a118388957fbc584f312dbe69" id="r_af273ca9a118388957fbc584f312dbe69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af273ca9a118388957fbc584f312dbe69">perturbation</a> (const std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; &amp;paths)</td></tr>
<tr class="separator:af273ca9a118388957fbc584f312dbe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd474564c90d5889134a07e55ec8517" id="r_abfd474564c90d5889134a07e55ec8517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfd474564c90d5889134a07e55ec8517">submit_task</a> (const std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; &amp;paths, const std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt; &amp;<a class="el" href="#a9a118a2adc98188629ff83420b7af441">nodes</a>)</td></tr>
<tr class="separator:abfd474564c90d5889134a07e55ec8517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738e70f8bad0b68497da8f85d41d3f4" id="r_a7738e70f8bad0b68497da8f85d41d3f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7738e70f8bad0b68497da8f85d41d3f4">get_labels</a> ()</td></tr>
<tr class="separator:a7738e70f8bad0b68497da8f85d41d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe5299c9ba0783008d8b6e93bef9f223" id="r_abe5299c9ba0783008d8b6e93bef9f223"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5299c9ba0783008d8b6e93bef9f223">order_crossover</a> (const std::vector&lt; int &gt; &amp;parent1, const std::vector&lt; int &gt; &amp;parent2, int i, int j)</td></tr>
<tr class="separator:abe5299c9ba0783008d8b6e93bef9f223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a82f1ff351e51b47c3489bc8fb57d" id="r_aed5a82f1ff351e51b47c3489bc8fb57d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed5a82f1ff351e51b47c3489bc8fb57d">two_opt</a> (const std::vector&lt; uint16_t &gt; &amp;route, int i, int j)</td></tr>
<tr class="memdesc:aed5a82f1ff351e51b47c3489bc8fb57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-opt optimization on a given route.  <br /></td></tr>
<tr class="separator:aed5a82f1ff351e51b47c3489bc8fb57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a75465311932a906c7e891d960af07f3a" id="r_a75465311932a906c7e891d960af07f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInstanceData.html">InstanceData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75465311932a906c7e891d960af07f3a">instance</a></td></tr>
<tr class="separator:a75465311932a906c7e891d960af07f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a118a2adc98188629ff83420b7af441" id="r_a9a118a2adc98188629ff83420b7af441"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a118a2adc98188629ff83420b7af441">nodes</a></td></tr>
<tr class="separator:a9a118a2adc98188629ff83420b7af441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1bb3898a10101301bd2ad70ff80885" id="r_a5b1bb3898a10101301bd2ad70ff80885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCutStorage.html">CutStorage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b1bb3898a10101301bd2ad70ff80885">cut_storage</a> = nullptr</td></tr>
<tr class="separator:a5b1bb3898a10101301bd2ad70ff80885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcda4d6fbc4237f3fffaf6d83e62c8d9" id="r_afcda4d6fbc4237f3fffaf6d83e62c8d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="#ae2fa6e2669be463de56ce1fd34cf3684">OperatorFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcda4d6fbc4237f3fffaf6d83e62c8d9">operators</a></td></tr>
<tr class="separator:afcda4d6fbc4237f3fffaf6d83e62c8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e98e0d60a2fb80776aaaeec403b1a4" id="r_a84e98e0d60a2fb80776aaaeec403b1a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a> = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}</td></tr>
<tr class="separator:a84e98e0d60a2fb80776aaaeec403b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b380a567901e7c9295dbaca6f87218" id="r_a38b380a567901e7c9295dbaca6f87218"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a></td></tr>
<tr class="separator:a38b380a567901e7c9295dbaca6f87218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54e9f0f61870575438092ad5111da8" id="r_a0c54e9f0f61870575438092ad5111da8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c54e9f0f61870575438092ad5111da8">operator_success_count</a> = {0, 0, 0, 0, 0, 0, 0}</td></tr>
<tr class="separator:a0c54e9f0f61870575438092ad5111da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a79b16f83e5f0809583b1be374af6b" id="r_a82a79b16f83e5f0809583b1be374af6b"><td class="memItemLeft" align="right" valign="top">exec::static_thread_pool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a79b16f83e5f0809583b1be374af6b">pool</a></td></tr>
<tr class="separator:a82a79b16f83e5f0809583b1be374af6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473972fc44e0c9dfefe3a04f5cb4f792" id="r_a473972fc44e0c9dfefe3a04f5cb4f792"><td class="memItemLeft" align="right" valign="top">exec::static_thread_pool::scheduler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a473972fc44e0c9dfefe3a04f5cb4f792">sched</a> = pool.get_scheduler()</td></tr>
<tr class="separator:a473972fc44e0c9dfefe3a04f5cb4f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0736d613aa45e64be75d3220d2d1e678" id="r_a0736d613aa45e64be75d3220d2d1e678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0736d613aa45e64be75d3220d2d1e678">rng</a></td></tr>
<tr class="separator:a0736d613aa45e64be75d3220d2d1e678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1802ead6559727270637186b88336f7" id="r_aa1802ead6559727270637186b88336f7"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1802ead6559727270637186b88336f7">operator_mutex</a></td></tr>
<tr class="separator:aa1802ead6559727270637186b88336f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00020">20</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae2fa6e2669be463de56ce1fd34cf3684" name="ae2fa6e2669be463de56ce1fd34cf3684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fa6e2669be463de56ce1fd34cf3684">&#9670;&#160;</a></span>OperatorFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae2fa6e2669be463de56ce1fd34cf3684">IteratedLocalSearch::OperatorFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        std::pair&lt;std::vector&lt;uint16_t&gt;, std::vector&lt;uint16_t&gt;&gt; (</div>
<div class="line">            <a class="code hl_function" href="#a5139ace2f7924ec0838aadf2051d6533">IteratedLocalSearch</a>::*)(<span class="keyword">const</span> std::vector&lt;uint16_t&gt; &amp;,</div>
<div class="line">                                    <span class="keyword">const</span> std::vector&lt;uint16_t&gt; &amp;, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a5139ace2f7924ec0838aadf2051d6533"><div class="ttname"><a href="#a5139ace2f7924ec0838aadf2051d6533">IteratedLocalSearch::IteratedLocalSearch</a></div><div class="ttdeci">IteratedLocalSearch(const InstanceData &amp;instance)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00027">RIH.h:27</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00485">485</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5139ace2f7924ec0838aadf2051d6533" name="a5139ace2f7924ec0838aadf2051d6533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5139ace2f7924ec0838aadf2051d6533">&#9670;&#160;</a></span>IteratedLocalSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratedLocalSearch::IteratedLocalSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structInstanceData.html">InstanceData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00027">27</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   28</span>        : <a class="code hl_variable" href="#a75465311932a906c7e891d960af07f3a">instance</a>(<a class="code hl_variable" href="#a75465311932a906c7e891d960af07f3a">instance</a>),</div>
<div class="line"><span class="lineno">   29</span>          <a class="code hl_variable" href="#a82a79b16f83e5f0809583b1be374af6b">pool</a>(5),</div>
<div class="line"><span class="lineno">   30</span>          <a class="code hl_variable" href="#a473972fc44e0c9dfefe3a04f5cb4f792">sched</a>(<a class="code hl_variable" href="#a82a79b16f83e5f0809583b1be374af6b">pool</a>.get_scheduler()),</div>
<div class="line"><span class="lineno">   31</span>          task_queue(5, <a class="code hl_variable" href="#a473972fc44e0c9dfefe3a04f5cb4f792">sched</a>, *<span class="keyword">this</span>) {}</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a473972fc44e0c9dfefe3a04f5cb4f792"><div class="ttname"><a href="#a473972fc44e0c9dfefe3a04f5cb4f792">IteratedLocalSearch::sched</a></div><div class="ttdeci">exec::static_thread_pool::scheduler sched</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00570">RIH.h:570</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a75465311932a906c7e891d960af07f3a"><div class="ttname"><a href="#a75465311932a906c7e891d960af07f3a">IteratedLocalSearch::instance</a></div><div class="ttdeci">InstanceData instance</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00022">RIH.h:22</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a82a79b16f83e5f0809583b1be374af6b"><div class="ttname"><a href="#a82a79b16f83e5f0809583b1be374af6b">IteratedLocalSearch::pool</a></div><div class="ttdeci">exec::static_thread_pool pool</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00568">RIH.h:568</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a54c703d2dcdc3b1f88f2012451e8f3bc" name="a54c703d2dcdc3b1f88f2012451e8f3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c703d2dcdc3b1f88f2012451e8f3bc">&#9670;&#160;</a></span>~IteratedLocalSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratedLocalSearch::~IteratedLocalSearch </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00033">33</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   33</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abab6b57e4edf8ee77d1fc8872eef68d6" name="abab6b57e4edf8ee77d1fc8872eef68d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab6b57e4edf8ee77d1fc8872eef68d6">&#9670;&#160;</a></span>apply_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::apply_operator </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>op_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00512">512</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  514</span>                                                         {</div>
<div class="line"><span class="lineno">  515</span>        <span class="keywordflow">return</span> (this-&gt;*<a class="code hl_variable" href="#afcda4d6fbc4237f3fffaf6d83e62c8d9">operators</a>[op_index])(route1, route2, k, l);</div>
<div class="line"><span class="lineno">  516</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_afcda4d6fbc4237f3fffaf6d83e62c8d9"><div class="ttname"><a href="#afcda4d6fbc4237f3fffaf6d83e62c8d9">IteratedLocalSearch::operators</a></div><div class="ttdeci">std::vector&lt; OperatorFunc &gt; operators</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00489">RIH.h:489</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3a385fcceeeac471cab42d124f7f4dae" name="a3a385fcceeeac471cab42d124f7f4dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a385fcceeeac471cab42d124f7f4dae">&#9670;&#160;</a></span>compute_insertion_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IteratedLocalSearch::compute_insertion_cost </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>chain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>original_cost</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00433">433</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  435</span>                                                        {</div>
<div class="line"><span class="lineno">  436</span>        <span class="comment">// Simulate the insertion and calculate the cost incrementally</span></div>
<div class="line"><span class="lineno">  437</span>        std::vector&lt;uint16_t&gt; new_route(route.size() + chain.size());</div>
<div class="line"><span class="lineno">  438</span>        std::copy(route.begin(), route.begin() + pos, new_route.begin());</div>
<div class="line"><span class="lineno">  439</span>        std::copy(chain.begin(), chain.end(), new_route.begin() + pos);</div>
<div class="line"><span class="lineno">  440</span>        std::copy(route.begin() + pos, route.end(),</div>
<div class="line"><span class="lineno">  441</span>                  new_route.begin() + pos + chain.size());</div>
<div class="line"><span class="lineno">  442</span> </div>
<div class="line"><span class="lineno">  443</span>        <span class="keywordflow">return</span> this-&gt;compute_cost(new_route).second;</div>
<div class="line"><span class="lineno">  444</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51e952673bf5b27eb6491d7a24eab2b8" name="a51e952673bf5b27eb6491d7a24eab2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e952673bf5b27eb6491d7a24eab2b8">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::cross </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a crossover operation between two routes at specified positions. </p>
<p>This function takes two routes and two crossover points, and swaps the tails of the routes after the specified positions. The depots (first and last elements) are not allowed to be crossover points. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00207">207</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  209</span>                                                         {</div>
<div class="line"><span class="lineno">  210</span>        <span class="comment">// Ensure valid crossover points that do not involve depots</span></div>
<div class="line"><span class="lineno">  211</span>        <span class="keywordflow">if</span> (k &lt;= 0 || k &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size()) - 1 || l &lt;= 0 ||</div>
<div class="line"><span class="lineno">  212</span>            l &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size()) - 1) {</div>
<div class="line"><span class="lineno">  213</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  214</span>        }</div>
<div class="line"><span class="lineno">  215</span> </div>
<div class="line"><span class="lineno">  216</span>        <span class="comment">// Create new routes by swapping tails</span></div>
<div class="line"><span class="lineno">  217</span>        std::vector&lt;uint16_t&gt; new_route1(route1.begin(), route1.begin() + k);</div>
<div class="line"><span class="lineno">  218</span>        new_route1.insert(new_route1.end(), route2.begin() + l, route2.end());</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>        std::vector&lt;uint16_t&gt; new_route2(route2.begin(), route2.begin() + l);</div>
<div class="line"><span class="lineno">  221</span>        new_route2.insert(new_route2.end(), route1.begin() + k, route1.end());</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">return</span> {std::move(new_route1), std::move(new_route2)};</div>
<div class="line"><span class="lineno">  224</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa55d7fcdce5a31d6805b71942ca039e1" name="aa55d7fcdce5a31d6805b71942ca039e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55d7fcdce5a31d6805b71942ca039e1">&#9670;&#160;</a></span>enhanced_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::enhanced_swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps segments of varying lengths between two routes. </p>
<p>This function takes two routes and swaps segments of up to 3 elements between them, starting at specified indices. If the start index is at the beginning or end of a route, no changes are made to avoid swapping depot nodes. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00172">172</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  174</span>                                                         {</div>
<div class="line"><span class="lineno">  175</span>        <span class="comment">// Check if indices are valid and do not involve depots</span></div>
<div class="line"><span class="lineno">  176</span>        <span class="keywordflow">if</span> (i &lt;= 0 || i &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size()) - 1 || j &lt;= 0 ||</div>
<div class="line"><span class="lineno">  177</span>            j &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size()) - 1) {</div>
<div class="line"><span class="lineno">  178</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  179</span>        }</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>        <span class="comment">// Determine maximum segment length to swap (up to 3 elements)</span></div>
<div class="line"><span class="lineno">  182</span>        <span class="keywordtype">int</span> max_segment_length = 3;</div>
<div class="line"><span class="lineno">  183</span>        <span class="keywordtype">int</span> segment_length =</div>
<div class="line"><span class="lineno">  184</span>            std::min({max_segment_length, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size() - i),</div>
<div class="line"><span class="lineno">  185</span>                      <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size() - j)});</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span>        std::vector&lt;uint16_t&gt; new_route1(route1);</div>
<div class="line"><span class="lineno">  188</span>        std::vector&lt;uint16_t&gt; new_route2(route2);</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>        <span class="comment">// Swap the segments between the two routes</span></div>
<div class="line"><span class="lineno">  191</span>        std::swap_ranges(new_route1.begin() + i,</div>
<div class="line"><span class="lineno">  192</span>                         new_route1.begin() + i + segment_length,</div>
<div class="line"><span class="lineno">  193</span>                         new_route2.begin() + j);</div>
<div class="line"><span class="lineno">  194</span> </div>
<div class="line"><span class="lineno">  195</span>        <span class="keywordflow">return</span> {std::move(new_route1), std::move(new_route2)};</div>
<div class="line"><span class="lineno">  196</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac035fef647f1bfd845ad6efa45f1ada6" name="ac035fef647f1bfd845ad6efa45f1ada6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac035fef647f1bfd845ad6efa45f1ada6">&#9670;&#160;</a></span>extended_relocate_star()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::extended_relocate_star </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>chain_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relocates a sequence of customers from one route to another. </p>
<p>This operator moves a chain of 2 or 3 consecutive customers from one route to another. The depots (first and last elements) are not involved. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00453">453</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  455</span>                                                 {</div>
<div class="line"><span class="lineno">  456</span>        <span class="comment">// Ensure we are not relocating depot nodes or exceeding bounds</span></div>
<div class="line"><span class="lineno">  457</span>        <span class="keywordflow">if</span> (i == 0 || i + chain_length &gt; route1.size() - 1 || j == 0 ||</div>
<div class="line"><span class="lineno">  458</span>            j == route2.size() - 1) {</div>
<div class="line"><span class="lineno">  459</span>            <span class="keywordflow">return</span> {route1, route2};  <span class="comment">// No changes if depots or out-of-bound</span></div>
<div class="line"><span class="lineno">  460</span>                                      <span class="comment">// indices are involved</span></div>
<div class="line"><span class="lineno">  461</span>        }</div>
<div class="line"><span class="lineno">  462</span> </div>
<div class="line"><span class="lineno">  463</span>        <span class="comment">// Relocate a chain of customers from route1 to route2</span></div>
<div class="line"><span class="lineno">  464</span>        std::vector&lt;uint16_t&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  465</span>        std::vector&lt;uint16_t&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span>        <span class="comment">// Extract the chain of customers to relocate</span></div>
<div class="line"><span class="lineno">  468</span>        std::vector&lt;uint16_t&gt; chain(new_route1.begin() + i,</div>
<div class="line"><span class="lineno">  469</span>                                    new_route1.begin() + i + chain_length);</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span>        <span class="comment">// Remove the chain from route1</span></div>
<div class="line"><span class="lineno">  472</span>        new_route1.erase(new_route1.begin() + i,</div>
<div class="line"><span class="lineno">  473</span>                         new_route1.begin() + i + chain_length);</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>        <span class="comment">// Insert the chain into route2 at position j</span></div>
<div class="line"><span class="lineno">  476</span>        new_route2.insert(new_route2.begin() + j, chain.begin(), chain.end());</div>
<div class="line"><span class="lineno">  477</span> </div>
<div class="line"><span class="lineno">  478</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  479</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a765ead85470b515f70b3795548f2fe0c" name="a765ead85470b515f70b3795548f2fe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765ead85470b515f70b3795548f2fe0c">&#9670;&#160;</a></span>extended_swap_star()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::extended_swap_star </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps sequences of customers between two routes and inserts them at optimal positions. </p>
<p>This operator swaps a chain of 2 or 3 consecutive customers between two routes, and inserts each chain into the best possible position in the opposite route, ensuring depots are not involved. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00352">352</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  354</span>                                                         {</div>
<div class="line"><span class="lineno">  355</span>        <span class="comment">// Call the actual extended_swap_star with a default chain length of 2</span></div>
<div class="line"><span class="lineno">  356</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="#a54c19f98bcafced3fb5c662687878d96">extended_swap_star_fun</a>(route1, route2, i, j, 2);</div>
<div class="line"><span class="lineno">  357</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a54c19f98bcafced3fb5c662687878d96"><div class="ttname"><a href="#a54c19f98bcafced3fb5c662687878d96">IteratedLocalSearch::extended_swap_star_fun</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; extended_swap_star_fun(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j, int chain_length=2)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00360">RIH.h:360</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_a765ead85470b515f70b3795548f2fe0c_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_a765ead85470b515f70b3795548f2fe0c_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_a765ead85470b515f70b3795548f2fe0c_cgraph" id="aclassIteratedLocalSearch_a765ead85470b515f70b3795548f2fe0c_cgraph">
<area shape="rect" title="Swaps sequences of customers between two routes and inserts them at optimal positions." alt="" coords="5,13,152,54"/>
<area shape="rect" href="classIteratedLocalSearch.html#a54c19f98bcafced3fb5c662687878d96" title=" " alt="" coords="200,13,371,54"/>
<area shape="poly" title=" " alt="" coords="152,30,184,30,184,36,152,36"/>
<area shape="rect" href="classIteratedLocalSearch.html#a6c668d676ee2fc23b820b54088412925" title="Finds the best position to insert a chain of customers into a route." alt="" coords="419,5,557,61"/>
<area shape="poly" title=" " alt="" coords="372,30,404,30,404,36,372,36"/>
<area shape="rect" href="classIteratedLocalSearch.html#a3a385fcceeeac471cab42d124f7f4dae" title=" " alt="" coords="605,13,771,54"/>
<area shape="poly" title=" " alt="" coords="558,30,590,30,590,36,558,36"/>
</map>
</div>

</div>
</div>
<a id="a54c19f98bcafced3fb5c662687878d96" name="a54c19f98bcafced3fb5c662687878d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c19f98bcafced3fb5c662687878d96">&#9670;&#160;</a></span>extended_swap_star_fun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::extended_swap_star_fun </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>chain_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00360">360</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  362</span>                                                 {</div>
<div class="line"><span class="lineno">  363</span>        <span class="comment">// Ensure indices are within bounds and do not involve depot nodes</span></div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">if</span> (i &lt;= 0 || i + chain_length &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size()) ||</div>
<div class="line"><span class="lineno">  365</span>            j &lt;= 0 || j + chain_length &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size())) {</div>
<div class="line"><span class="lineno">  366</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  367</span>        }</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>        <span class="comment">// Create mutable copies of the routes</span></div>
<div class="line"><span class="lineno">  370</span>        std::vector&lt;uint16_t&gt; new_route1(route1.begin(), route1.end());</div>
<div class="line"><span class="lineno">  371</span>        std::vector&lt;uint16_t&gt; new_route2(route2.begin(), route2.end());</div>
<div class="line"><span class="lineno">  372</span> </div>
<div class="line"><span class="lineno">  373</span>        <span class="comment">// Extract and erase chains in-place</span></div>
<div class="line"><span class="lineno">  374</span>        <span class="keyword">auto</span> chain1_start = new_route1.begin() + i;</div>
<div class="line"><span class="lineno">  375</span>        <span class="keyword">auto</span> chain1_end = chain1_start + chain_length;</div>
<div class="line"><span class="lineno">  376</span>        std::vector&lt;uint16_t&gt; chain1(std::make_move_iterator(chain1_start),</div>
<div class="line"><span class="lineno">  377</span>                                     std::make_move_iterator(chain1_end));</div>
<div class="line"><span class="lineno">  378</span>        new_route1.erase(chain1_start, chain1_end);</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span>        <span class="keyword">auto</span> chain2_start = new_route2.begin() + j;</div>
<div class="line"><span class="lineno">  381</span>        <span class="keyword">auto</span> chain2_end = chain2_start + chain_length;</div>
<div class="line"><span class="lineno">  382</span>        std::vector&lt;uint16_t&gt; chain2(std::make_move_iterator(chain2_start),</div>
<div class="line"><span class="lineno">  383</span>                                     std::make_move_iterator(chain2_end));</div>
<div class="line"><span class="lineno">  384</span>        new_route2.erase(chain2_start, chain2_end);</div>
<div class="line"><span class="lineno">  385</span> </div>
<div class="line"><span class="lineno">  386</span>        <span class="comment">// Find the best insertion positions</span></div>
<div class="line"><span class="lineno">  387</span>        <span class="keywordtype">int</span> best_pos_route1 = <a class="code hl_function" href="#a6c668d676ee2fc23b820b54088412925">find_best_insertion_position</a>(new_route1, chain2);</div>
<div class="line"><span class="lineno">  388</span>        <span class="keywordtype">int</span> best_pos_route2 = <a class="code hl_function" href="#a6c668d676ee2fc23b820b54088412925">find_best_insertion_position</a>(new_route2, chain1);</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span>        <span class="comment">// Insert the chains at the best positions</span></div>
<div class="line"><span class="lineno">  391</span>        new_route1.insert(new_route1.begin() + best_pos_route1,</div>
<div class="line"><span class="lineno">  392</span>                          std::make_move_iterator(chain2.begin()),</div>
<div class="line"><span class="lineno">  393</span>                          std::make_move_iterator(chain2.end()));</div>
<div class="line"><span class="lineno">  394</span>        new_route2.insert(new_route2.begin() + best_pos_route2,</div>
<div class="line"><span class="lineno">  395</span>                          std::make_move_iterator(chain1.begin()),</div>
<div class="line"><span class="lineno">  396</span>                          std::make_move_iterator(chain1.end()));</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span>        <span class="keywordflow">return</span> {std::move(new_route1), std::move(new_route2)};</div>
<div class="line"><span class="lineno">  399</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a6c668d676ee2fc23b820b54088412925"><div class="ttname"><a href="#a6c668d676ee2fc23b820b54088412925">IteratedLocalSearch::find_best_insertion_position</a></div><div class="ttdeci">int find_best_insertion_position(const std::vector&lt; uint16_t &gt; &amp;route, const std::vector&lt; uint16_t &gt; &amp;chain)</div><div class="ttdoc">Finds the best position to insert a chain of customers into a route.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00409">RIH.h:409</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_a54c19f98bcafced3fb5c662687878d96_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_a54c19f98bcafced3fb5c662687878d96_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_a54c19f98bcafced3fb5c662687878d96_cgraph" id="aclassIteratedLocalSearch_a54c19f98bcafced3fb5c662687878d96_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,177,54"/>
<area shape="rect" href="classIteratedLocalSearch.html#a6c668d676ee2fc23b820b54088412925" title="Finds the best position to insert a chain of customers into a route." alt="" coords="225,5,363,61"/>
<area shape="poly" title=" " alt="" coords="177,30,209,30,209,36,177,36"/>
<area shape="rect" href="classIteratedLocalSearch.html#a3a385fcceeeac471cab42d124f7f4dae" title=" " alt="" coords="411,13,576,54"/>
<area shape="poly" title=" " alt="" coords="364,30,395,30,395,36,364,36"/>
</map>
</div>

</div>
</div>
<a id="a6c668d676ee2fc23b820b54088412925" name="a6c668d676ee2fc23b820b54088412925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c668d676ee2fc23b820b54088412925">&#9670;&#160;</a></span>find_best_insertion_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IteratedLocalSearch::find_best_insertion_position </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>chain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the best position to insert a chain of customers into a route. </p>
<p>This helper function evaluates the cost of inserting a chain into each possible position in the route and returns the index of the best insertion point. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00409">409</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  410</span>                                                                       {</div>
<div class="line"><span class="lineno">  411</span>        <span class="keywordtype">int</span> best_pos = 1;</div>
<div class="line"><span class="lineno">  412</span>        <span class="keywordtype">double</span> best_cost = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>        <span class="comment">// Precompute the cost of the original route</span></div>
<div class="line"><span class="lineno">  415</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> original_cost = this-&gt;compute_cost(route).second;</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>        <span class="comment">// Iterate over valid insertion positions</span></div>
<div class="line"><span class="lineno">  418</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos = 1; pos &lt; static_cast&lt;int&gt;(route.size()); ++pos) {</div>
<div class="line"><span class="lineno">  419</span>            <span class="comment">// Incrementally compute the new cost for inserting the chain at</span></div>
<div class="line"><span class="lineno">  420</span>            <span class="comment">// position `pos`</span></div>
<div class="line"><span class="lineno">  421</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> incremental_cost =</div>
<div class="line"><span class="lineno">  422</span>                <a class="code hl_function" href="#a3a385fcceeeac471cab42d124f7f4dae">compute_insertion_cost</a>(route, chain, pos, original_cost);</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>            <span class="comment">// Track the best position based on the cost</span></div>
<div class="line"><span class="lineno">  425</span>            <span class="keywordflow">if</span> (incremental_cost &lt; best_cost) {</div>
<div class="line"><span class="lineno">  426</span>                best_cost = incremental_cost;</div>
<div class="line"><span class="lineno">  427</span>                best_pos = pos;</div>
<div class="line"><span class="lineno">  428</span>            }</div>
<div class="line"><span class="lineno">  429</span>        }</div>
<div class="line"><span class="lineno">  430</span>        <span class="keywordflow">return</span> best_pos;</div>
<div class="line"><span class="lineno">  431</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a3a385fcceeeac471cab42d124f7f4dae"><div class="ttname"><a href="#a3a385fcceeeac471cab42d124f7f4dae">IteratedLocalSearch::compute_insertion_cost</a></div><div class="ttdeci">double compute_insertion_cost(const std::vector&lt; uint16_t &gt; &amp;route, const std::vector&lt; uint16_t &gt; &amp;chain, int pos, double original_cost)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00433">RIH.h:433</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_a6c668d676ee2fc23b820b54088412925_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_a6c668d676ee2fc23b820b54088412925_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_a6c668d676ee2fc23b820b54088412925_cgraph" id="aclassIteratedLocalSearch_a6c668d676ee2fc23b820b54088412925_cgraph">
<area shape="rect" title="Finds the best position to insert a chain of customers into a route." alt="" coords="5,5,144,61"/>
<area shape="rect" href="classIteratedLocalSearch.html#a3a385fcceeeac471cab42d124f7f4dae" title=" " alt="" coords="192,13,357,54"/>
<area shape="poly" title=" " alt="" coords="144,30,176,30,176,36,144,36"/>
</map>
</div>

</div>
</div>
<a id="a7738e70f8bad0b68497da8f85d41d3f4" name="a7738e70f8bad0b68497da8f85d41d3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7738e70f8bad0b68497da8f85d41d3f4">&#9670;&#160;</a></span>get_labels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; IteratedLocalSearch::get_labels </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00719">719</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  719</span>                                    {</div>
<div class="line"><span class="lineno">  720</span>        <span class="keyword">auto</span> tasks = task_queue.get_processed_tasks();</div>
<div class="line"><span class="lineno">  721</span>        std::vector&lt;Label *&gt; result;</div>
<div class="line"><span class="lineno">  722</span>        result.insert(result.end(), tasks.begin(), tasks.end());</div>
<div class="line"><span class="lineno">  723</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  724</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a50de1ef7dc5a829711ed08667d75161f" name="a50de1ef7dc5a829711ed08667d75161f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50de1ef7dc5a829711ed08667d75161f">&#9670;&#160;</a></span>insertion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::insertion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a customer from one route into another route at specified positions. </p>
<p>This function takes two routes and inserts a customer from the first route at position <code>k</code> into the second route at position <code>l</code>. It ensures that depots (first and last positions) are not involved in the insertion process. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00236">236</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  238</span>                                                         {</div>
<div class="line"><span class="lineno">  239</span>        <span class="comment">// Ensure valid positions that do not involve depots</span></div>
<div class="line"><span class="lineno">  240</span>        <span class="keywordflow">if</span> (k &lt;= 0 || k &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size()) - 1 || l &lt; 0 ||</div>
<div class="line"><span class="lineno">  241</span>            l &gt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size())) {</div>
<div class="line"><span class="lineno">  242</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  243</span>        }</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span>        <span class="comment">// Copy routes and perform insertion</span></div>
<div class="line"><span class="lineno">  246</span>        std::vector&lt;uint16_t&gt; new_route1(route1);</div>
<div class="line"><span class="lineno">  247</span>        std::vector&lt;uint16_t&gt; new_route2(route2);</div>
<div class="line"><span class="lineno">  248</span> </div>
<div class="line"><span class="lineno">  249</span>        <span class="comment">// Extract the customer from route1</span></div>
<div class="line"><span class="lineno">  250</span>        <span class="keywordtype">int</span> customer =</div>
<div class="line"><span class="lineno">  251</span>            std::move(new_route1[k]);  <span class="comment">// Move to avoid unnecessary copying</span></div>
<div class="line"><span class="lineno">  252</span>        new_route1.erase(new_route1.begin() + k);</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>        <span class="comment">// Insert the customer into route2</span></div>
<div class="line"><span class="lineno">  255</span>        new_route2.insert(new_route2.begin() + l, std::move(customer));</div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span>        <span class="keywordflow">return</span> {std::move(new_route1), std::move(new_route2)};</div>
<div class="line"><span class="lineno">  258</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4fdc6d03b30abfb18bd90a0240f8a34" name="ae4fdc6d03b30abfb18bd90a0240f8a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fdc6d03b30abfb18bd90a0240f8a34">&#9670;&#160;</a></span>move_two_clients_reversed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::move_two_clients_reversed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00323">323</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  325</span>                                     {</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">if</span> (i == 0 || i + 1 &gt;= route1.size() || j == 0 || j &gt;= route2.size()) {</div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  328</span>        }</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span>        std::vector&lt;uint16_t&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  331</span>        std::vector&lt;uint16_t&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>        <span class="comment">// Extract the chain and reverse it</span></div>
<div class="line"><span class="lineno">  334</span>        std::vector&lt;uint16_t&gt; chain = {new_route1[i], new_route1[i + 1]};</div>
<div class="line"><span class="lineno">  335</span>        std::reverse(chain.begin(), chain.end());</div>
<div class="line"><span class="lineno">  336</span> </div>
<div class="line"><span class="lineno">  337</span>        new_route1.erase(new_route1.begin() + i, new_route1.begin() + i + 2);</div>
<div class="line"><span class="lineno">  338</span>        new_route2.insert(new_route2.begin() + j, chain.begin(), chain.end());</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  341</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f2b3dd4e5bc9b112f765455ba1d2fda" name="a4f2b3dd4e5bc9b112f765455ba1d2fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2b3dd4e5bc9b112f765455ba1d2fda">&#9670;&#160;</a></span>nm_exchange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::nm_exchange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00286">286</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  288</span>                                                         {</div>
<div class="line"><span class="lineno">  289</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="#a428b3f95156f560faf7eba8f398b4894">nm_exchange_fun</a>(route1, route2, i, j, 2, 1);</div>
<div class="line"><span class="lineno">  290</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a428b3f95156f560faf7eba8f398b4894"><div class="ttname"><a href="#a428b3f95156f560faf7eba8f398b4894">IteratedLocalSearch::nm_exchange_fun</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; nm_exchange_fun(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j, int n=2, int m=1)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00293">RIH.h:293</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_a4f2b3dd4e5bc9b112f765455ba1d2fda_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_a4f2b3dd4e5bc9b112f765455ba1d2fda_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_a4f2b3dd4e5bc9b112f765455ba1d2fda_cgraph" id="aclassIteratedLocalSearch_a4f2b3dd4e5bc9b112f765455ba1d2fda_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,144,46"/>
<area shape="rect" href="classIteratedLocalSearch.html#a428b3f95156f560faf7eba8f398b4894" title=" " alt="" coords="192,5,330,46"/>
<area shape="poly" title=" " alt="" coords="144,23,176,23,176,28,144,28"/>
</map>
</div>

</div>
</div>
<a id="a428b3f95156f560faf7eba8f398b4894" name="a428b3f95156f560faf7eba8f398b4894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428b3f95156f560faf7eba8f398b4894">&#9670;&#160;</a></span>nm_exchange_fun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::nm_exchange_fun </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>m</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00293">293</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  296</span>                   {</div>
<div class="line"><span class="lineno">  297</span>        <span class="keywordflow">if</span> (i == 0 || j == 0 || i + n &gt; route1.size() ||</div>
<div class="line"><span class="lineno">  298</span>            j + m &gt; route2.size()) {</div>
<div class="line"><span class="lineno">  299</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  300</span>        }</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>        std::vector&lt;uint16_t&gt; new_route1 = route1;</div>
<div class="line"><span class="lineno">  303</span>        std::vector&lt;uint16_t&gt; new_route2 = route2;</div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span>        <span class="comment">// Extract chains</span></div>
<div class="line"><span class="lineno">  306</span>        std::vector&lt;uint16_t&gt; chain1(new_route1.begin() + i,</div>
<div class="line"><span class="lineno">  307</span>                                     new_route1.begin() + i + n);</div>
<div class="line"><span class="lineno">  308</span>        std::vector&lt;uint16_t&gt; chain2(new_route2.begin() + j,</div>
<div class="line"><span class="lineno">  309</span>                                     new_route2.begin() + j + m);</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>        <span class="comment">// Swap the chains</span></div>
<div class="line"><span class="lineno">  312</span>        new_route1.erase(new_route1.begin() + i, new_route1.begin() + i + n);</div>
<div class="line"><span class="lineno">  313</span>        new_route2.erase(new_route2.begin() + j, new_route2.begin() + j + m);</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>        new_route1.insert(new_route1.begin() + i, chain2.begin(), chain2.end());</div>
<div class="line"><span class="lineno">  316</span>        new_route2.insert(new_route2.begin() + j, chain1.begin(), chain1.end());</div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordflow">return</span> {new_route1, new_route2};</div>
<div class="line"><span class="lineno">  319</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abe5299c9ba0783008d8b6e93bef9f223" name="abe5299c9ba0783008d8b6e93bef9f223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5299c9ba0783008d8b6e93bef9f223">&#9670;&#160;</a></span>order_crossover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; int &gt; IteratedLocalSearch::order_crossover </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00035">35</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   37</span>                                                          {</div>
<div class="line"><span class="lineno">   38</span>        <span class="keywordtype">int</span> n = parent1.size();</div>
<div class="line"><span class="lineno">   39</span>        <span class="keywordflow">if</span> (i &lt; 0 || j &gt;= n || i &gt;= j) {</div>
<div class="line"><span class="lineno">   40</span>            <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid crossover points.&quot;</span>);</div>
<div class="line"><span class="lineno">   41</span>        }</div>
<div class="line"><span class="lineno">   42</span> </div>
<div class="line"><span class="lineno">   43</span>        <span class="comment">// Initialize offspring with placeholders (-1 indicates empty)</span></div>
<div class="line"><span class="lineno">   44</span>        std::vector&lt;int&gt; offspring(n, -1);</div>
<div class="line"><span class="lineno">   45</span> </div>
<div class="line"><span class="lineno">   46</span>        <span class="comment">// Copy segment from parent1</span></div>
<div class="line"><span class="lineno">   47</span>        std::copy(parent1.begin() + i, parent1.begin() + j + 1,</div>
<div class="line"><span class="lineno">   48</span>                  offspring.begin() + i);</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span>        <span class="comment">// Fill remaining positions with elements from parent2</span></div>
<div class="line"><span class="lineno">   51</span>        <span class="keyword">auto</span> it = parent2.begin();</div>
<div class="line"><span class="lineno">   52</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; n; ++k) {</div>
<div class="line"><span class="lineno">   53</span>            <span class="keywordflow">if</span> (offspring[k] == -1) {  <span class="comment">// Empty slot in offspring</span></div>
<div class="line"><span class="lineno">   54</span>                <span class="comment">// Skip elements already present in the offspring</span></div>
<div class="line"><span class="lineno">   55</span>                <span class="keywordflow">while</span> (std::find(offspring.begin(), offspring.end(), *it) !=</div>
<div class="line"><span class="lineno">   56</span>                       offspring.end()) {</div>
<div class="line"><span class="lineno">   57</span>                    ++it;</div>
<div class="line"><span class="lineno">   58</span>                }</div>
<div class="line"><span class="lineno">   59</span>                offspring[k] = *it;</div>
<div class="line"><span class="lineno">   60</span>                ++it;</div>
<div class="line"><span class="lineno">   61</span>            }</div>
<div class="line"><span class="lineno">   62</span>        }</div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span>        <span class="keywordflow">return</span> offspring;</div>
<div class="line"><span class="lineno">   65</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af273ca9a118388957fbc584f312dbe69" name="af273ca9a118388957fbc584f312dbe69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af273ca9a118388957fbc584f312dbe69">&#9670;&#160;</a></span>perturbation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; IteratedLocalSearch::perturbation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00575">575</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  575</span>                                                                     {</div>
<div class="line"><span class="lineno">  576</span>        <span class="comment">// Copy the input paths as the baseline best solution.</span></div>
<div class="line"><span class="lineno">  577</span>        std::vector&lt;Label *&gt; best = paths;</div>
<div class="line"><span class="lineno">  578</span>        std::vector&lt;Label *&gt; best_new;</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordtype">bool</span> is_stuck = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  581</span>        <span class="comment">// Initialize best costs for each path to a large value.</span></div>
<div class="line"><span class="lineno">  582</span>        std::vector&lt;double&gt; best_costs(paths.size(),</div>
<div class="line"><span class="lineno">  583</span>                                       std::numeric_limits&lt;double&gt;::max());</div>
<div class="line"><span class="lineno">  584</span> </div>
<div class="line"><span class="lineno">  585</span>        <span class="comment">// Reserve an approximate number of tasks if possible.</span></div>
<div class="line"><span class="lineno">  586</span>        std::vector&lt;std::tuple&lt;const Label *, const Label *, size_t, size_t&gt;&gt;</div>
<div class="line"><span class="lineno">  587</span>            tasks;</div>
<div class="line"><span class="lineno">  588</span>        tasks.reserve(paths.size() * paths.size() *</div>
<div class="line"><span class="lineno">  589</span>                      4);  <span class="comment">// adjust estimate as needed</span></div>
<div class="line"><span class="lineno">  590</span> </div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> Label *label_i : best) {</div>
<div class="line"><span class="lineno">  592</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> Label *label_j : best) {</div>
<div class="line"><span class="lineno">  593</span>                <span class="keywordflow">if</span> (label_i == label_j) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  594</span>                <span class="keyword">const</span> <span class="keyword">auto</span> &amp;route_i = label_i-&gt;nodes_covered;</div>
<div class="line"><span class="lineno">  595</span>                <span class="keyword">const</span> <span class="keyword">auto</span> &amp;route_j = label_j-&gt;nodes_covered;</div>
<div class="line"><span class="lineno">  596</span>                <span class="comment">// Skip if routes are too short.</span></div>
<div class="line"><span class="lineno">  597</span>                <span class="keywordflow">if</span> (route_i.size() &lt; 3 || route_j.size() &lt; 3) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  598</span>                <span class="comment">// Generate tasks for valid internal positions.</span></div>
<div class="line"><span class="lineno">  599</span>                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 1; k &lt; route_i.size() - 1; ++k) {</div>
<div class="line"><span class="lineno">  600</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> l = 1; l &lt; route_j.size() - 1; ++l) {</div>
<div class="line"><span class="lineno">  601</span>                        tasks.emplace_back(label_i, label_j, k, l);</div>
<div class="line"><span class="lineno">  602</span>                    }</div>
<div class="line"><span class="lineno">  603</span>                }</div>
<div class="line"><span class="lineno">  604</span>            }</div>
<div class="line"><span class="lineno">  605</span>        }</div>
<div class="line"><span class="lineno">  606</span> </div>
<div class="line"><span class="lineno">  607</span>        <span class="comment">// We&#39;ll use per-chunk local storage to avoid locking per improvement.</span></div>
<div class="line"><span class="lineno">  608</span>        <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_tasks = tasks.size();</div>
<div class="line"><span class="lineno">  609</span>        <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size = 1;  <span class="comment">// Adjust chunk size based on experiments.</span></div>
<div class="line"><span class="lineno">  610</span>        <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_chunks = (num_tasks + chunk_size - 1) / chunk_size;</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>        <span class="comment">// Prepare a vector of per-chunk improved labels.</span></div>
<div class="line"><span class="lineno">  613</span>        std::vector&lt;std::vector&lt;Label *&gt;&gt; local_best_new(num_chunks);</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>        <span class="comment">// Optionally, you can also create per-chunk accumulators for operator</span></div>
<div class="line"><span class="lineno">  616</span>        <span class="comment">// metrics. For brevity, we&#39;ll leave operator metric updates using</span></div>
<div class="line"><span class="lineno">  617</span>        <span class="comment">// locks.</span></div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>        <span class="keyword">auto</span> bulk_sender = stdexec::bulk(</div>
<div class="line"><span class="lineno">  620</span>            stdexec::just(), num_chunks,</div>
<div class="line"><span class="lineno">  621</span>            [&amp;tasks, chunk_size, &amp;local_best_new, <span class="keyword">this</span>](std::size_t chunk_idx) {</div>
<div class="line"><span class="lineno">  622</span>                <span class="keyword">const</span> <span class="keywordtype">size_t</span> start_idx = chunk_idx * chunk_size;</div>
<div class="line"><span class="lineno">  623</span>                <span class="keyword">const</span> <span class="keywordtype">size_t</span> end_idx =</div>
<div class="line"><span class="lineno">  624</span>                    std::min(start_idx + chunk_size, tasks.size());</div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>                <span class="comment">// Local vector to accumulate improved labels.</span></div>
<div class="line"><span class="lineno">  627</span>                std::vector&lt;Label *&gt; local_improvements;</div>
<div class="line"><span class="lineno">  628</span>                local_improvements.reserve(10);</div>
<div class="line"><span class="lineno">  629</span> </div>
<div class="line"><span class="lineno">  630</span>                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> task_idx = start_idx; task_idx &lt; end_idx;</div>
<div class="line"><span class="lineno">  631</span>                     ++task_idx) {</div>
<div class="line"><span class="lineno">  632</span>                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;[label_i, label_j, k, l] = tasks[task_idx];</div>
<div class="line"><span class="lineno">  633</span>                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;route_i = label_i-&gt;getRoute();</div>
<div class="line"><span class="lineno">  634</span>                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;route_j = label_j-&gt;getRoute();</div>
<div class="line"><span class="lineno">  635</span> </div>
<div class="line"><span class="lineno">  636</span>                    <span class="keywordflow">if</span> (route_i.size() &lt; 3 || route_j.size() &lt; 3) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  637</span> </div>
<div class="line"><span class="lineno">  638</span>                    <span class="comment">// Select operator based on its weight.</span></div>
<div class="line"><span class="lineno">  639</span>                    <span class="keywordtype">int</span> op_idx = <a class="code hl_function" href="#a0537178b1dabf661440b847b8b87f7e8">select_operator</a>(<a class="code hl_variable" href="#a0736d613aa45e64be75d3220d2d1e678">rng</a>);</div>
<div class="line"><span class="lineno">  640</span> </div>
<div class="line"><span class="lineno">  641</span>                    <span class="comment">// Apply the chosen operator.</span></div>
<div class="line"><span class="lineno">  642</span>                    <span class="keyword">auto</span> [new_route_i, new_route_j] =</div>
<div class="line"><span class="lineno">  643</span>                        <a class="code hl_function" href="#abab6b57e4edf8ee77d1fc8872eef68d6">apply_operator</a>(op_idx, route_i, route_j, k, l);</div>
<div class="line"><span class="lineno">  644</span>                    <span class="keywordflow">if</span> (new_route_i.empty() || new_route_j.empty()) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>                    <span class="comment">// Compute new route costs.</span></div>
<div class="line"><span class="lineno">  647</span>                    <span class="keyword">auto</span> cost_i = compute_cost(new_route_i);</div>
<div class="line"><span class="lineno">  648</span>                    <span class="keyword">auto</span> cost_j = compute_cost(new_route_j);</div>
<div class="line"><span class="lineno">  649</span>                    Path new_path_i{new_route_i, cost_i.first};</div>
<div class="line"><span class="lineno">  650</span>                    Path new_path_j{new_route_j, cost_j.first};</div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span>                    <span class="comment">// Lambda to update a label if an improvement is found.</span></div>
<div class="line"><span class="lineno">  653</span>                    <span class="keyword">auto</span> add_improved_label =</div>
<div class="line"><span class="lineno">  654</span>                        [&amp;](<span class="keyword">const</span> Path &amp;path,</div>
<div class="line"><span class="lineno">  655</span>                            <span class="keyword">const</span> std::pair&lt;double, double&gt; &amp;cost,</div>
<div class="line"><span class="lineno">  656</span>                            <span class="keyword">const</span> Label *orig_label, <span class="keywordtype">int</span> op_idx) {</div>
<div class="line"><span class="lineno">  657</span>                            <span class="keywordtype">double</span> new_cost = cost.second;</div>
<div class="line"><span class="lineno">  658</span>                            <span class="keywordtype">double</span> current_cost = orig_label-&gt;cost;</div>
<div class="line"><span class="lineno">  659</span>                            <span class="keywordflow">if</span> (new_cost &lt; current_cost - 1e-3) {</div>
<div class="line"><span class="lineno">  660</span>                                <span class="comment">// Update operator performance metrics.</span></div>
<div class="line"><span class="lineno">  661</span>                                {</div>
<div class="line"><span class="lineno">  662</span>                                    std::lock_guard&lt;std::mutex&gt; lock(</div>
<div class="line"><span class="lineno">  663</span>                                        <a class="code hl_variable" href="#aa1802ead6559727270637186b88336f7">operator_mutex</a>);</div>
<div class="line"><span class="lineno">  664</span>                                    <a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>[op_idx] +=</div>
<div class="line"><span class="lineno">  665</span>                                        current_cost - new_cost;</div>
<div class="line"><span class="lineno">  666</span>                                    <a class="code hl_variable" href="#a0c54e9f0f61870575438092ad5111da8">operator_success_count</a>[op_idx] += 1;</div>
<div class="line"><span class="lineno">  667</span>                                }</div>
<div class="line"><span class="lineno">  668</span>                                <span class="comment">// Create a new improved label.</span></div>
<div class="line"><span class="lineno">  669</span>                                <span class="keyword">auto</span> best_new_label = <span class="keyword">new</span> Label();</div>
<div class="line"><span class="lineno">  670</span>                                best_new_label-&gt;addRoute(path.<a class="code hl_variable" href="structPath.html#aefc192566c08e16358f1f13e2f23a5a8">route</a>);</div>
<div class="line"><span class="lineno">  671</span>                                best_new_label-&gt;real_cost = cost.first;</div>
<div class="line"><span class="lineno">  672</span>                                best_new_label-&gt;cost = new_cost;</div>
<div class="line"><span class="lineno">  673</span>                                local_improvements.push_back(best_new_label);</div>
<div class="line"><span class="lineno">  674</span>                            }</div>
<div class="line"><span class="lineno">  675</span>                        };</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span>                    <span class="keywordflow">if</span> (is_feasible(new_path_i))</div>
<div class="line"><span class="lineno">  678</span>                        add_improved_label(new_path_i, cost_i, label_i, op_idx);</div>
<div class="line"><span class="lineno">  679</span>                    <span class="keywordflow">if</span> (is_feasible(new_path_j))</div>
<div class="line"><span class="lineno">  680</span>                        add_improved_label(new_path_j, cost_j, label_j, op_idx);</div>
<div class="line"><span class="lineno">  681</span>                }</div>
<div class="line"><span class="lineno">  682</span>                <span class="comment">// Save the local improvements for this chunk.</span></div>
<div class="line"><span class="lineno">  683</span>                local_best_new[chunk_idx] = std::move(local_improvements);</div>
<div class="line"><span class="lineno">  684</span>            });</div>
<div class="line"><span class="lineno">  685</span> </div>
<div class="line"><span class="lineno">  686</span>        <span class="comment">// Submit work and wait for completion.</span></div>
<div class="line"><span class="lineno">  687</span>        <span class="keyword">auto</span> work = stdexec::starts_on(<a class="code hl_variable" href="#a473972fc44e0c9dfefe3a04f5cb4f792">sched</a>, bulk_sender);</div>
<div class="line"><span class="lineno">  688</span>        stdexec::sync_wait(std::move(work));</div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span>        <span class="comment">// Merge local improvements into the global best_new vector.</span></div>
<div class="line"><span class="lineno">  691</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;vec : local_best_new) {</div>
<div class="line"><span class="lineno">  692</span>            best_new.insert(best_new.end(), vec.begin(), vec.end());</div>
<div class="line"><span class="lineno">  693</span>        }</div>
<div class="line"><span class="lineno">  694</span> </div>
<div class="line"><span class="lineno">  695</span>        <span class="comment">// Update the operator weights based on the collected performance.</span></div>
<div class="line"><span class="lineno">  696</span>        <a class="code hl_function" href="#a03cbc1c0cb18d27433f706b51628dbdf">update_operator_weights</a>();</div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>        <span class="comment">// Sort the improved labels and keep only the top N_ADD solutions.</span></div>
<div class="line"><span class="lineno">  699</span>        pdqsort(</div>
<div class="line"><span class="lineno">  700</span>            best_new.begin(), best_new.end(),</div>
<div class="line"><span class="lineno">  701</span>            [](<span class="keyword">const</span> Label *a, <span class="keyword">const</span> Label *b) { return a-&gt;cost &lt; b-&gt;cost; });</div>
<div class="line"><span class="lineno">  702</span>        <span class="keywordflow">if</span> (best_new.size() &gt; N_ADD) {</div>
<div class="line"><span class="lineno">  703</span>            best_new.erase(best_new.begin() + N_ADD, best_new.end());</div>
<div class="line"><span class="lineno">  704</span>        }</div>
<div class="line"><span class="lineno">  705</span> </div>
<div class="line"><span class="lineno">  706</span>        <span class="keywordflow">return</span> best_new;</div>
<div class="line"><span class="lineno">  707</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a03cbc1c0cb18d27433f706b51628dbdf"><div class="ttname"><a href="#a03cbc1c0cb18d27433f706b51628dbdf">IteratedLocalSearch::update_operator_weights</a></div><div class="ttdeci">void update_operator_weights(double decay_factor=0.9, double reward_factor=0.1, double min_weight=0.01)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00518">RIH.h:518</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a0537178b1dabf661440b847b8b87f7e8"><div class="ttname"><a href="#a0537178b1dabf661440b847b8b87f7e8">IteratedLocalSearch::select_operator</a></div><div class="ttdeci">int select_operator(Xoroshiro128Plus &amp;rng)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00505">RIH.h:505</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a0736d613aa45e64be75d3220d2d1e678"><div class="ttname"><a href="#a0736d613aa45e64be75d3220d2d1e678">IteratedLocalSearch::rng</a></div><div class="ttdeci">Xoroshiro128Plus rng</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00572">RIH.h:572</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a0c54e9f0f61870575438092ad5111da8"><div class="ttname"><a href="#a0c54e9f0f61870575438092ad5111da8">IteratedLocalSearch::operator_success_count</a></div><div class="ttdeci">std::vector&lt; int &gt; operator_success_count</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00501">RIH.h:501</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a38b380a567901e7c9295dbaca6f87218"><div class="ttname"><a href="#a38b380a567901e7c9295dbaca6f87218">IteratedLocalSearch::operator_improvements</a></div><div class="ttdeci">std::vector&lt; double &gt; operator_improvements</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00499">RIH.h:499</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_aa1802ead6559727270637186b88336f7"><div class="ttname"><a href="#aa1802ead6559727270637186b88336f7">IteratedLocalSearch::operator_mutex</a></div><div class="ttdeci">std::mutex operator_mutex</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00573">RIH.h:573</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_abab6b57e4edf8ee77d1fc8872eef68d6"><div class="ttname"><a href="#abab6b57e4edf8ee77d1fc8872eef68d6">IteratedLocalSearch::apply_operator</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; apply_operator(int op_index, const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00512">RIH.h:512</a></div></div>
<div class="ttc" id="astructPath_html_aefc192566c08e16358f1f13e2f23a5a8"><div class="ttname"><a href="structPath.html#aefc192566c08e16358f1f13e2f23a5a8">Path::route</a></div><div class="ttdeci">std::vector&lt; uint16_t &gt; route</div><div class="ttdef"><b>Definition</b> <a href="Path_8h_source.html#l00023">Path.h:23</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIteratedLocalSearch_af273ca9a118388957fbc584f312dbe69_cgraph.png" border="0" usemap="#aclassIteratedLocalSearch_af273ca9a118388957fbc584f312dbe69_cgraph" alt=""/></div>
<map name="aclassIteratedLocalSearch_af273ca9a118388957fbc584f312dbe69_cgraph" id="aclassIteratedLocalSearch_af273ca9a118388957fbc584f312dbe69_cgraph">
<area shape="rect" title=" " alt="" coords="5,71,144,111"/>
<area shape="rect" href="classIteratedLocalSearch.html#abab6b57e4edf8ee77d1fc8872eef68d6" title=" " alt="" coords="209,5,347,46"/>
<area shape="poly" title=" " alt="" coords="139,68,197,49,198,54,141,73"/>
<area shape="rect" href="classIteratedLocalSearch.html#a0537178b1dabf661440b847b8b87f7e8" title=" " alt="" coords="209,71,347,111"/>
<area shape="poly" title=" " alt="" coords="144,88,193,88,193,94,144,94"/>
<area shape="rect" href="classIteratedLocalSearch.html#a03cbc1c0cb18d27433f706b51628dbdf" title=" " alt="" coords="192,136,364,177"/>
<area shape="poly" title=" " alt="" coords="141,109,198,128,197,133,139,114"/>
</map>
</div>

</div>
</div>
<a id="adae8f4d483cf54d105d1578642b86a66" name="adae8f4d483cf54d105d1578642b86a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae8f4d483cf54d105d1578642b86a66">&#9670;&#160;</a></span>relocate_star()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::relocate_star </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relocates a customer from one route to another. </p>
<p>This function relocates the customer at position <code>i</code> in <code>route1</code> to position <code>j</code> in <code>route2</code>. If the positions <code>i</code> or <code>j</code> involve depots (i.e., the first or last positions in the routes), no changes are made and the original routes are returned. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00140">140</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  142</span>                                                         {</div>
<div class="line"><span class="lineno">  143</span>        <span class="comment">// Check if indices are valid and do not involve depots</span></div>
<div class="line"><span class="lineno">  144</span>        <span class="keywordflow">if</span> (i &lt;= 0 || i &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size()) - 1 || j &lt; 0 ||</div>
<div class="line"><span class="lineno">  145</span>            j &gt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size())) {</div>
<div class="line"><span class="lineno">  146</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  147</span>        }</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>        <span class="comment">// Perform relocation</span></div>
<div class="line"><span class="lineno">  150</span>        std::vector&lt;uint16_t&gt; new_route1(route1.begin(), route1.end());</div>
<div class="line"><span class="lineno">  151</span>        std::vector&lt;uint16_t&gt; new_route2(route2.begin(), route2.end());</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>        <span class="comment">// Extract and move customer</span></div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordtype">int</span> customer = std::move(new_route1[i]);</div>
<div class="line"><span class="lineno">  155</span>        new_route1.erase(new_route1.begin() +</div>
<div class="line"><span class="lineno">  156</span>                         i);  <span class="comment">// Remove customer from route1</span></div>
<div class="line"><span class="lineno">  157</span>        new_route2.insert(new_route2.begin() + j,</div>
<div class="line"><span class="lineno">  158</span>                          customer);  <span class="comment">// Insert into route2</span></div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">return</span> {std::move(new_route1), std::move(new_route2)};</div>
<div class="line"><span class="lineno">  161</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0537178b1dabf661440b847b8b87f7e8" name="a0537178b1dabf661440b847b8b87f7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0537178b1dabf661440b847b8b87f7e8">&#9670;&#160;</a></span>select_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IteratedLocalSearch::select_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rng</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00505">505</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  505</span>                                               {</div>
<div class="line"><span class="lineno">  506</span>        std::discrete_distribution&lt;int&gt; dist(<a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.begin(),</div>
<div class="line"><span class="lineno">  507</span>                                             <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.end());</div>
<div class="line"><span class="lineno">  508</span>        <span class="keywordflow">return</span> dist(<a class="code hl_variable" href="#a0736d613aa45e64be75d3220d2d1e678">rng</a>);</div>
<div class="line"><span class="lineno">  509</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a84e98e0d60a2fb80776aaaeec403b1a4"><div class="ttname"><a href="#a84e98e0d60a2fb80776aaaeec403b1a4">IteratedLocalSearch::operator_weights</a></div><div class="ttdeci">std::vector&lt; double &gt; operator_weights</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00498">RIH.h:498</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac407b2b6df160cc5783c5e2f48c095ae" name="ac407b2b6df160cc5783c5e2f48c095ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac407b2b6df160cc5783c5e2f48c095ae">&#9670;&#160;</a></span>srex_crossover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::srex_crossover </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00067">67</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   69</span>                                                          {</div>
<div class="line"><span class="lineno">   70</span>        <span class="keywordtype">int</span> n = parent1.size();</div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">if</span> (i &lt; 0 || j &gt;= n || i &gt;= j) {</div>
<div class="line"><span class="lineno">   72</span>            <span class="keywordflow">return</span> {parent1, parent2};</div>
<div class="line"><span class="lineno">   73</span>        }</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span>        <span class="comment">// Copy subroutes</span></div>
<div class="line"><span class="lineno">   76</span>        std::vector&lt;uint16_t&gt; segment1(parent1.begin() + i,</div>
<div class="line"><span class="lineno">   77</span>                                       parent1.begin() + j + 1);</div>
<div class="line"><span class="lineno">   78</span>        std::vector&lt;uint16_t&gt; segment2(parent2.begin() + i,</div>
<div class="line"><span class="lineno">   79</span>                                       parent2.begin() + j + 1);</div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>        <span class="comment">// Create offspring by swapping the segments</span></div>
<div class="line"><span class="lineno">   82</span>        std::vector&lt;uint16_t&gt; offspring1, offspring2;</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>        <span class="comment">// Insert segment2 into parent1 and reconstruct</span></div>
<div class="line"><span class="lineno">   85</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node : parent1) {</div>
<div class="line"><span class="lineno">   86</span>            <span class="keywordflow">if</span> (std::find(segment2.begin(), segment2.end(), node) ==</div>
<div class="line"><span class="lineno">   87</span>                segment2.end()) {</div>
<div class="line"><span class="lineno">   88</span>                offspring1.push_back(</div>
<div class="line"><span class="lineno">   89</span>                    node);  <span class="comment">// Add nodes not in the swapped segment</span></div>
<div class="line"><span class="lineno">   90</span>            }</div>
<div class="line"><span class="lineno">   91</span>        }</div>
<div class="line"><span class="lineno">   92</span>        offspring1.insert(offspring1.begin() + i, segment2.begin(),</div>
<div class="line"><span class="lineno">   93</span>                          segment2.end());</div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span>        <span class="comment">// Insert segment1 into parent2 and reconstruct</span></div>
<div class="line"><span class="lineno">   96</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node : parent2) {</div>
<div class="line"><span class="lineno">   97</span>            <span class="keywordflow">if</span> (std::find(segment1.begin(), segment1.end(), node) ==</div>
<div class="line"><span class="lineno">   98</span>                segment1.end()) {</div>
<div class="line"><span class="lineno">   99</span>                offspring2.push_back(</div>
<div class="line"><span class="lineno">  100</span>                    node);  <span class="comment">// Add nodes not in the swapped segment</span></div>
<div class="line"><span class="lineno">  101</span>            }</div>
<div class="line"><span class="lineno">  102</span>        }</div>
<div class="line"><span class="lineno">  103</span>        offspring2.insert(offspring2.begin() + i, segment1.begin(),</div>
<div class="line"><span class="lineno">  104</span>                          segment1.end());</div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>        <span class="keywordflow">return</span> {std::move(offspring1), std::move(offspring2)};</div>
<div class="line"><span class="lineno">  107</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abfd474564c90d5889134a07e55ec8517" name="abfd474564c90d5889134a07e55ec8517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd474564c90d5889134a07e55ec8517">&#9670;&#160;</a></span>submit_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IteratedLocalSearch::submit_task </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structLabel.html">Label</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structVRPNode.html">VRPNode</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00710">710</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  711</span>                                                      {</div>
<div class="line"><span class="lineno">  712</span>        this-&gt;<a class="code hl_variable" href="#a9a118a2adc98188629ff83420b7af441">nodes</a> = <a class="code hl_variable" href="#a9a118a2adc98188629ff83420b7af441">nodes</a>;</div>
<div class="line"><span class="lineno">  713</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;path : paths) {</div>
<div class="line"><span class="lineno">  714</span>            task_queue.submit_task(path);</div>
<div class="line"><span class="lineno">  715</span>        }</div>
<div class="line"><span class="lineno">  716</span>    }</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a9a118a2adc98188629ff83420b7af441"><div class="ttname"><a href="#a9a118a2adc98188629ff83420b7af441">IteratedLocalSearch::nodes</a></div><div class="ttdeci">std::vector&lt; VRPNode &gt; nodes</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00023">RIH.h:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a573128d044c04146324e6abb05ad4fb9" name="a573128d044c04146324e6abb05ad4fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573128d044c04146324e6abb05ad4fb9">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; IteratedLocalSearch::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps customers between two routes at specified positions. </p>
<p>This function takes two routes and swaps the customers at the specified positions k and l. It ensures that depot positions (first and last elements) are not swapped. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00268">268</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  270</span>                                                         {</div>
<div class="line"><span class="lineno">  271</span>        <span class="comment">// Ensure valid swap positions that do not involve depots</span></div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordflow">if</span> (k &lt;= 0 || k &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route1.size()) - 1 || l &lt;= 0 ||</div>
<div class="line"><span class="lineno">  273</span>            l &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route2.size()) - 1) {</div>
<div class="line"><span class="lineno">  274</span>            <span class="keywordflow">return</span> {route1, route2};</div>
<div class="line"><span class="lineno">  275</span>        }</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span>        <span class="comment">// Swap customers between route1 and route2</span></div>
<div class="line"><span class="lineno">  278</span>        std::vector&lt;uint16_t&gt; new_route1(route1);</div>
<div class="line"><span class="lineno">  279</span>        std::vector&lt;uint16_t&gt; new_route2(route2);</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>        std::swap(new_route1[k], new_route2[l]);</div>
<div class="line"><span class="lineno">  282</span> </div>
<div class="line"><span class="lineno">  283</span>        <span class="keywordflow">return</span> {std::move(new_route1), std::move(new_route2)};</div>
<div class="line"><span class="lineno">  284</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed5a82f1ff351e51b47c3489bc8fb57d" name="aed5a82f1ff351e51b47c3489bc8fb57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a82f1ff351e51b47c3489bc8fb57d">&#9670;&#160;</a></span>two_opt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; uint16_t &gt; IteratedLocalSearch::two_opt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>route</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the 2-opt optimization on a given route. </p>
<p>This function takes a route and two indices, i and j, and returns a new route where the segment between i and j is reversed. The function ensures that the indices are within bounds and that the depots (first and last elements) are not involved in the reversal. </p>

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00118">118</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  119</span>                                                       {</div>
<div class="line"><span class="lineno">  120</span>        <span class="comment">// Validate indices and ensure they do not include depots</span></div>
<div class="line"><span class="lineno">  121</span>        <span class="keywordflow">if</span> (i &lt;= 0 || j &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(route.size()) - 1 || i &gt;= j) {</div>
<div class="line"><span class="lineno">  122</span>            <span class="keywordflow">return</span> route;</div>
<div class="line"><span class="lineno">  123</span>        }</div>
<div class="line"><span class="lineno">  124</span> </div>
<div class="line"><span class="lineno">  125</span>        <span class="comment">// Perform the 2-opt operation by reversing the segment between i and j</span></div>
<div class="line"><span class="lineno">  126</span>        std::vector&lt;uint16_t&gt; new_route(route);</div>
<div class="line"><span class="lineno">  127</span>        std::reverse(new_route.begin() + i, new_route.begin() + j + 1);</div>
<div class="line"><span class="lineno">  128</span>        <span class="keywordflow">return</span> new_route;</div>
<div class="line"><span class="lineno">  129</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a03cbc1c0cb18d27433f706b51628dbdf" name="a03cbc1c0cb18d27433f706b51628dbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cbc1c0cb18d27433f706b51628dbdf">&#9670;&#160;</a></span>update_operator_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IteratedLocalSearch::update_operator_weights </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>decay_factor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>reward_factor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.01</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00518">518</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  520</span>                                                           {</div>
<div class="line"><span class="lineno">  521</span>        <span class="comment">// First, compute total improvement and total successes.</span></div>
<div class="line"><span class="lineno">  522</span>        <span class="keywordtype">double</span> total_improvement = 0.0;</div>
<div class="line"><span class="lineno">  523</span>        <span class="keywordtype">int</span> total_successes = 0;</div>
<div class="line"><span class="lineno">  524</span>        <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>.size();</div>
<div class="line"><span class="lineno">  525</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; ++i) {</div>
<div class="line"><span class="lineno">  526</span>            total_improvement += <a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>[i];</div>
<div class="line"><span class="lineno">  527</span>            total_successes += <a class="code hl_variable" href="#a0c54e9f0f61870575438092ad5111da8">operator_success_count</a>[i];</div>
<div class="line"><span class="lineno">  528</span>        }</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>        <span class="comment">// Only update weights if we have any recorded improvement or success.</span></div>
<div class="line"><span class="lineno">  531</span>        <span class="keywordflow">if</span> (total_improvement &gt; 0 || total_successes &gt; 0) {</div>
<div class="line"><span class="lineno">  532</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> inv_total_improvement =</div>
<div class="line"><span class="lineno">  533</span>                (total_improvement &gt; 0) ? (1.0 / total_improvement) : 0.0;</div>
<div class="line"><span class="lineno">  534</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> inv_total_successes =</div>
<div class="line"><span class="lineno">  535</span>                (total_successes &gt; 0) ? (1.0 / total_successes) : 0.0;</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>            <span class="comment">// Update each operator weight and accumulate the total weight.</span></div>
<div class="line"><span class="lineno">  538</span>            <span class="keywordtype">double</span> total_weight = 0.0;</div>
<div class="line"><span class="lineno">  539</span>            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; ++i) {</div>
<div class="line"><span class="lineno">  540</span>                <span class="keywordtype">double</span> normalized_improvement =</div>
<div class="line"><span class="lineno">  541</span>                    <a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>[i] * inv_total_improvement;</div>
<div class="line"><span class="lineno">  542</span>                <span class="keywordtype">double</span> success_rate =</div>
<div class="line"><span class="lineno">  543</span>                    <a class="code hl_variable" href="#a0c54e9f0f61870575438092ad5111da8">operator_success_count</a>[i] * inv_total_successes;</div>
<div class="line"><span class="lineno">  544</span>                <span class="keywordtype">double</span> new_weight =</div>
<div class="line"><span class="lineno">  545</span>                    decay_factor * <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>[i] +</div>
<div class="line"><span class="lineno">  546</span>                    reward_factor * (normalized_improvement + success_rate);</div>
<div class="line"><span class="lineno">  547</span>                <span class="comment">// Ensure a minimum weight.</span></div>
<div class="line"><span class="lineno">  548</span>                <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>[i] =</div>
<div class="line"><span class="lineno">  549</span>                    (new_weight &lt; min_weight) ? min_weight : new_weight;</div>
<div class="line"><span class="lineno">  550</span>                total_weight += <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>[i];</div>
<div class="line"><span class="lineno">  551</span>            }</div>
<div class="line"><span class="lineno">  552</span> </div>
<div class="line"><span class="lineno">  553</span>            <span class="comment">// Normalize the weights so that they sum to 1.</span></div>
<div class="line"><span class="lineno">  554</span>            <span class="keywordflow">if</span> (total_weight &gt; 0.0) {</div>
<div class="line"><span class="lineno">  555</span>                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; ++i) {</div>
<div class="line"><span class="lineno">  556</span>                    <a class="code hl_variable" href="#a84e98e0d60a2fb80776aaaeec403b1a4">operator_weights</a>[i] /= total_weight;</div>
<div class="line"><span class="lineno">  557</span>                }</div>
<div class="line"><span class="lineno">  558</span>            }</div>
<div class="line"><span class="lineno">  559</span>        }</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>        <span class="comment">// Reset improvements and success counts for the next iteration.</span></div>
<div class="line"><span class="lineno">  562</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; ++i) {</div>
<div class="line"><span class="lineno">  563</span>            <a class="code hl_variable" href="#a38b380a567901e7c9295dbaca6f87218">operator_improvements</a>[i] = 0.0;</div>
<div class="line"><span class="lineno">  564</span>            <a class="code hl_variable" href="#a0c54e9f0f61870575438092ad5111da8">operator_success_count</a>[i] = 0;</div>
<div class="line"><span class="lineno">  565</span>        }</div>
<div class="line"><span class="lineno">  566</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5b1bb3898a10101301bd2ad70ff80885" name="a5b1bb3898a10101301bd2ad70ff80885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1bb3898a10101301bd2ad70ff80885">&#9670;&#160;</a></span>cut_storage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCutStorage.html">CutStorage</a>* IteratedLocalSearch::cut_storage = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00024">24</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a75465311932a906c7e891d960af07f3a" name="a75465311932a906c7e891d960af07f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75465311932a906c7e891d960af07f3a">&#9670;&#160;</a></span>instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInstanceData.html">InstanceData</a> IteratedLocalSearch::instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00022">22</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a9a118a2adc98188629ff83420b7af441" name="a9a118a2adc98188629ff83420b7af441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a118a2adc98188629ff83420b7af441">&#9670;&#160;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structVRPNode.html">VRPNode</a>&gt; IteratedLocalSearch::nodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00023">23</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a38b380a567901e7c9295dbaca6f87218" name="a38b380a567901e7c9295dbaca6f87218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b380a567901e7c9295dbaca6f87218">&#9670;&#160;</a></span>operator_improvements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IteratedLocalSearch::operator_improvements</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {0.0, 0.0, 0.0, 0.0,</div>
<div class="line">                                                 0.0, 0.0, 0.0}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00499">499</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  499</span>                                              {0.0, 0.0, 0.0, 0.0,</div>
<div class="line"><span class="lineno">  500</span>                                                 0.0, 0.0, 0.0};</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1802ead6559727270637186b88336f7" name="aa1802ead6559727270637186b88336f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1802ead6559727270637186b88336f7">&#9670;&#160;</a></span>operator_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex IteratedLocalSearch::operator_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00573">573</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a0c54e9f0f61870575438092ad5111da8" name="a0c54e9f0f61870575438092ad5111da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c54e9f0f61870575438092ad5111da8">&#9670;&#160;</a></span>operator_success_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; IteratedLocalSearch::operator_success_count = {0, 0, 0, 0, 0, 0, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00501">501</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  501</span>{0, 0, 0, 0, 0, 0, 0};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a84e98e0d60a2fb80776aaaeec403b1a4" name="a84e98e0d60a2fb80776aaaeec403b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e98e0d60a2fb80776aaaeec403b1a4">&#9670;&#160;</a></span>operator_weights</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IteratedLocalSearch::operator_weights = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00498">498</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  498</span>{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};</div>
</div><!-- fragment -->
</div>
</div>
<a id="afcda4d6fbc4237f3fffaf6d83e62c8d9" name="afcda4d6fbc4237f3fffaf6d83e62c8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcda4d6fbc4237f3fffaf6d83e62c8d9">&#9670;&#160;</a></span>operators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="#ae2fa6e2669be463de56ce1fd34cf3684">OperatorFunc</a>&gt; IteratedLocalSearch::operators</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        &amp;<a class="code hl_function" href="#a51e952673bf5b27eb6491d7a24eab2b8">IteratedLocalSearch::cross</a>,</div>
<div class="line">        &amp;<a class="code hl_function" href="#a50de1ef7dc5a829711ed08667d75161f">IteratedLocalSearch::insertion</a>,</div>
<div class="line">        &amp;<a class="code hl_function" href="#a573128d044c04146324e6abb05ad4fb9">IteratedLocalSearch::swap</a>,</div>
<div class="line">        &amp;<a class="code hl_function" href="#adae8f4d483cf54d105d1578642b86a66">IteratedLocalSearch::relocate_star</a>,</div>
<div class="line">        &amp;<a class="code hl_function" href="#aa55d7fcdce5a31d6805b71942ca039e1">IteratedLocalSearch::enhanced_swap</a>,</div>
<div class="line">        &amp;<a class="code hl_function" href="#ae4fdc6d03b30abfb18bd90a0240f8a34">IteratedLocalSearch::move_two_clients_reversed</a>,</div>
<div class="line">        &amp;<a class="code hl_function" href="#a765ead85470b515f70b3795548f2fe0c">IteratedLocalSearch::extended_swap_star</a>}</div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a50de1ef7dc5a829711ed08667d75161f"><div class="ttname"><a href="#a50de1ef7dc5a829711ed08667d75161f">IteratedLocalSearch::insertion</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; insertion(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</div><div class="ttdoc">Inserts a customer from one route into another route at specified positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00236">RIH.h:236</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a51e952673bf5b27eb6491d7a24eab2b8"><div class="ttname"><a href="#a51e952673bf5b27eb6491d7a24eab2b8">IteratedLocalSearch::cross</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; cross(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</div><div class="ttdoc">Performs a crossover operation between two routes at specified positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00207">RIH.h:207</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a573128d044c04146324e6abb05ad4fb9"><div class="ttname"><a href="#a573128d044c04146324e6abb05ad4fb9">IteratedLocalSearch::swap</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; swap(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int k, int l)</div><div class="ttdoc">Swaps customers between two routes at specified positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00268">RIH.h:268</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_a765ead85470b515f70b3795548f2fe0c"><div class="ttname"><a href="#a765ead85470b515f70b3795548f2fe0c">IteratedLocalSearch::extended_swap_star</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; extended_swap_star(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</div><div class="ttdoc">Swaps sequences of customers between two routes and inserts them at optimal positions.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00352">RIH.h:352</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_aa55d7fcdce5a31d6805b71942ca039e1"><div class="ttname"><a href="#aa55d7fcdce5a31d6805b71942ca039e1">IteratedLocalSearch::enhanced_swap</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; enhanced_swap(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</div><div class="ttdoc">Swaps segments of varying lengths between two routes.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00172">RIH.h:172</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_adae8f4d483cf54d105d1578642b86a66"><div class="ttname"><a href="#adae8f4d483cf54d105d1578642b86a66">IteratedLocalSearch::relocate_star</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; relocate_star(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</div><div class="ttdoc">Relocates a customer from one route to another.</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00140">RIH.h:140</a></div></div>
<div class="ttc" id="aclassIteratedLocalSearch_html_ae4fdc6d03b30abfb18bd90a0240f8a34"><div class="ttname"><a href="#ae4fdc6d03b30abfb18bd90a0240f8a34">IteratedLocalSearch::move_two_clients_reversed</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; uint16_t &gt;, std::vector&lt; uint16_t &gt; &gt; move_two_clients_reversed(const std::vector&lt; uint16_t &gt; &amp;route1, const std::vector&lt; uint16_t &gt; &amp;route2, int i, int j)</div><div class="ttdef"><b>Definition</b> <a href="RIH_8h_source.html#l00323">RIH.h:323</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00489">489</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  489</span>                                        {</div>
<div class="line"><span class="lineno">  490</span>        &amp;<a class="code hl_function" href="#a51e952673bf5b27eb6491d7a24eab2b8">IteratedLocalSearch::cross</a>,</div>
<div class="line"><span class="lineno">  491</span>        &amp;<a class="code hl_function" href="#a50de1ef7dc5a829711ed08667d75161f">IteratedLocalSearch::insertion</a>,</div>
<div class="line"><span class="lineno">  492</span>        &amp;<a class="code hl_function" href="#a573128d044c04146324e6abb05ad4fb9">IteratedLocalSearch::swap</a>,</div>
<div class="line"><span class="lineno">  493</span>        &amp;<a class="code hl_function" href="#adae8f4d483cf54d105d1578642b86a66">IteratedLocalSearch::relocate_star</a>,</div>
<div class="line"><span class="lineno">  494</span>        &amp;<a class="code hl_function" href="#aa55d7fcdce5a31d6805b71942ca039e1">IteratedLocalSearch::enhanced_swap</a>,</div>
<div class="line"><span class="lineno">  495</span>        &amp;<a class="code hl_function" href="#ae4fdc6d03b30abfb18bd90a0240f8a34">IteratedLocalSearch::move_two_clients_reversed</a>,</div>
<div class="line"><span class="lineno">  496</span>        &amp;<a class="code hl_function" href="#a765ead85470b515f70b3795548f2fe0c">IteratedLocalSearch::extended_swap_star</a>};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82a79b16f83e5f0809583b1be374af6b" name="a82a79b16f83e5f0809583b1be374af6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a79b16f83e5f0809583b1be374af6b">&#9670;&#160;</a></span>pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exec::static_thread_pool IteratedLocalSearch::pool</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        exec::static_thread_pool(std::thread::hardware_concurrency() / 4)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00568">568</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a0736d613aa45e64be75d3220d2d1e678" name="a0736d613aa45e64be75d3220d2d1e678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0736d613aa45e64be75d3220d2d1e678">&#9670;&#160;</a></span>rng</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXoroshiro128Plus.html">Xoroshiro128Plus</a> IteratedLocalSearch::rng</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00572">572</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<a id="a473972fc44e0c9dfefe3a04f5cb4f792" name="a473972fc44e0c9dfefe3a04f5cb4f792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473972fc44e0c9dfefe3a04f5cb4f792">&#9670;&#160;</a></span>sched</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exec::static_thread_pool::scheduler IteratedLocalSearch::sched = pool.get_scheduler()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RIH_8h_source.html#l00570">570</a> of file <a class="el" href="RIH_8h_source.html">RIH.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RIH_8h_source.html">RIH.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classIteratedLocalSearch.html">IteratedLocalSearch</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
