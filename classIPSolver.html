<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BALDES: IPSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BALDES
   </div>
   <div id="projectbrief">Bucket Graph Labeling Algorithm for Vehicle Routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classIPSolver.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classIPSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IPSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for solving linear programming problems using an interior point method.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for IPSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver__coll__graph.png" border="0" usemap="#aIPSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aIPSolver_coll__map" id="aIPSolver_coll__map">
<area shape="rect" title="A class for solving linear programming problems using an interior point method." alt="" coords="65,94,136,120"/>
<area shape="rect" href="structResiduals.html" title="A structure to hold various residual vectors and their norms." alt="" coords="5,5,84,31"/>
<area shape="poly" title=" " alt="" coords="63,43,95,92,91,95,58,46"/>
<area shape="rect" href="classSparseSolver.html" title="A class for solving sparse linear systems using various solver types." alt="" coords="108,5,208,31"/>
<area shape="poly" title=" " alt="" coords="144,45,111,95,106,92,139,42"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61f035c65c660c2f0fcddc687388fb0d" id="r_a61f035c65c660c2f0fcddc687388fb0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f035c65c660c2f0fcddc687388fb0d">getDuals</a> () const</td></tr>
<tr class="separator:a61f035c65c660c2f0fcddc687388fb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b4972a25d69cc80c2a5f4676c1aa93" id="r_a87b4972a25d69cc80c2a5f4676c1aa93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b4972a25d69cc80c2a5f4676c1aa93">getPrimals</a> () const</td></tr>
<tr class="separator:a87b4972a25d69cc80c2a5f4676c1aa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6e8605bf4d41ddd7bf4f8f4384c0a1" id="r_aac6e8605bf4d41ddd7bf4f8f4384c0a1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac6e8605bf4d41ddd7bf4f8f4384c0a1">getObjective</a> () const</td></tr>
<tr class="separator:aac6e8605bf4d41ddd7bf4f8f4384c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365696b5a6356e7f9bc2d4b199fbc9f7" id="r_a365696b5a6356e7f9bc2d4b199fbc9f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365696b5a6356e7f9bc2d4b199fbc9f7">IPSolver</a> ()</td></tr>
<tr class="separator:a365696b5a6356e7f9bc2d4b199fbc9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ab576c321bd6a0506d9c5bf8362f1a" id="r_ad6ab576c321bd6a0506d9c5bf8362f1a"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6ab576c321bd6a0506d9c5bf8362f1a">convertToSparseDiagonal</a> (const Eigen::VectorXd &amp;vec)</td></tr>
<tr class="memdesc:ad6ab576c321bd6a0506d9c5bf8362f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dense vector to a sparse diagonal matrix.  <br /></td></tr>
<tr class="separator:ad6ab576c321bd6a0506d9c5bf8362f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecea75d40171352fa5298be01d3d007" id="r_a0ecea75d40171352fa5298be01d3d007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecea75d40171352fa5298be01d3d007">save_interior_solution</a> (const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;lambda, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;w, double <a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, double <a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a>)</td></tr>
<tr class="separator:a0ecea75d40171352fa5298be01d3d007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651221065511beedd53613296aaddcb" id="r_a2651221065511beedd53613296aaddcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2651221065511beedd53613296aaddcb">convert_to_standard_form</a> (const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, const Eigen::VectorXd &amp;sense, Eigen::SparseMatrix&lt; double &gt; &amp;As, Eigen::VectorXd &amp;bs, Eigen::VectorXd &amp;cs)</td></tr>
<tr class="memdesc:a2651221065511beedd53613296aaddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given linear programming problem to its standard form.  <br /></td></tr>
<tr class="separator:a2651221065511beedd53613296aaddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f22b1985e02e839ff3b2791a0389865" id="r_a1f22b1985e02e839ff3b2791a0389865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f22b1985e02e839ff3b2791a0389865">update_residuals</a> (<a class="el" href="structResiduals.html">Residuals</a> &amp;<a class="el" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>, const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;lambda, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;w, const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXi &amp;ubi, double <a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, double <a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a>)</td></tr>
<tr class="memdesc:a1f22b1985e02e839ff3b2791a0389865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the residuals for the interior point method solver.  <br /></td></tr>
<tr class="separator:a1f22b1985e02e839ff3b2791a0389865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c0e0acdfb28b73b2387a610bf8fbd6" id="r_a55c0e0acdfb28b73b2387a610bf8fbd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55c0e0acdfb28b73b2387a610bf8fbd6">solve_augmented_system</a> (Eigen::VectorXd &amp;dx, Eigen::VectorXd &amp;dy, <a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d)</td></tr>
<tr class="memdesc:a55c0e0acdfb28b73b2387a610bf8fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the augmented system for the given right-hand side vectors.  <br /></td></tr>
<tr class="separator:a55c0e0acdfb28b73b2387a610bf8fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d79c906c9f170d975b9404e793a14e" id="r_a10d79c906c9f170d975b9404e793a14e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d79c906c9f170d975b9404e793a14e">solve_augsys</a> (Eigen::VectorXd &amp;delta_x, Eigen::VectorXd &amp;delta_y, Eigen::VectorXd &amp;delta_z, <a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d, const Eigen::VectorXd &amp;xi_u)</td></tr>
<tr class="separator:a10d79c906c9f170d975b9404e793a14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac225cc4dcfe81ae25d3d59bdcb0b029f" id="r_ac225cc4dcfe81ae25d3d59bdcb0b029f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a> (Eigen::VectorXd &amp;Delta_x, Eigen::VectorXd &amp;Delta_lambda, Eigen::VectorXd &amp;Delta_w, Eigen::VectorXd &amp;Delta_s, Eigen::VectorXd &amp;Delta_v, double &amp;Delta_tau, double &amp;Delta_kappa, <a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXd &amp;delta_x, const Eigen::VectorXd &amp;delta_y, const Eigen::VectorXd &amp;delta_w, double delta_0, const Eigen::VectorXd &amp;iter_x, const Eigen::VectorXd &amp;iter_lambda, const Eigen::VectorXd &amp;iter_w, const Eigen::VectorXd &amp;iter_s, const Eigen::VectorXd &amp;iter_v, double iter_tau, double iter_kappa, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_u, const Eigen::VectorXd &amp;xi_d, double xi_g, const Eigen::VectorXd &amp;xi_xs, const Eigen::VectorXd &amp;xi_vw, double xi_tau_kappa)</td></tr>
<tr class="memdesc:ac225cc4dcfe81ae25d3d59bdcb0b029f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Newton system for the interior point method.  <br /></td></tr>
<tr class="separator:ac225cc4dcfe81ae25d3d59bdcb0b029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3037642e4e2090f62e90d9df5eee9f" id="r_add3037642e4e2090f62e90d9df5eee9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a> (const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv)</td></tr>
<tr class="memdesc:add3037642e4e2090f62e90d9df5eee9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum step size (alpha) for a single direction vector.  <br /></td></tr>
<tr class="separator:add3037642e4e2090f62e90d9df5eee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c38201e3fc179e9265a82e67510679" id="r_a16c38201e3fc179e9265a82e67510679"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a> (const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;dx, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;ds, const Eigen::VectorXd &amp;w, const Eigen::VectorXd &amp;dw, double <a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, double dtau, double <a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a>, double dkappa)</td></tr>
<tr class="memdesc:a16c38201e3fc179e9265a82e67510679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum step size (alpha) that can be taken along the direction of the search vectors.  <br /></td></tr>
<tr class="separator:a16c38201e3fc179e9265a82e67510679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc02635739446925971f247ee90227ad" id="r_acc02635739446925971f247ee90227ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc02635739446925971f247ee90227ad">run_optimization</a> (<a class="el" href="structModelData.html">ModelData</a> &amp;model, const double <a class="el" href="#ac1a5e7d41b0f72ce616f99b03d4785a5">tol</a>)</td></tr>
<tr class="memdesc:acc02635739446925971f247ee90227ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the optimization process on the given model data.  <br /></td></tr>
<tr class="separator:acc02635739446925971f247ee90227ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6983d42c0a0af7344a9c7f9b79cdfe" id="r_a2f6983d42c0a0af7344a9c7f9b79cdfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structOptimizationData.html">OptimizationData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">convertToOptimizationData</a> (const <a class="el" href="structModelData.html">ModelData</a> &amp;modelData)</td></tr>
<tr class="separator:a2f6983d42c0a0af7344a9c7f9b79cdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f7028c11d89b7986357f004f269924" id="r_a22f7028c11d89b7986357f004f269924"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f7028c11d89b7986357f004f269924">update_linear_solver</a> (<a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::VectorXd &amp;theta, const Eigen::VectorXd &amp;regP, const Eigen::VectorXd &amp;regD)</td></tr>
<tr class="separator:a22f7028c11d89b7986357f004f269924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac549fa9ef9fd8c98dc9262550a81f4d" id="r_aac549fa9ef9fd8c98dc9262550a81f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac549fa9ef9fd8c98dc9262550a81f4d">start_linear_solver</a> (<a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;<a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, const Eigen::SparseMatrix&lt; double &gt; A)</td></tr>
<tr class="separator:aac549fa9ef9fd8c98dc9262550a81f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d61bc3f60ab5545cbaf698cecc1d7" id="r_ac30d61bc3f60ab5545cbaf698cecc1d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structScalingFactors.html">ScalingFactors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac30d61bc3f60ab5545cbaf698cecc1d7">ruiz_scaling</a> (Eigen::SparseMatrix&lt; double &gt; &amp;A, Eigen::VectorXd &amp;b, Eigen::VectorXd &amp;c, Eigen::VectorXd &amp;lo, Eigen::VectorXd &amp;hi)</td></tr>
<tr class="separator:ac30d61bc3f60ab5545cbaf698cecc1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900ccac531085de01e8e3a60e2eca4bd" id="r_a900ccac531085de01e8e3a60e2eca4bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a900ccac531085de01e8e3a60e2eca4bd">unscale_solution</a> (Eigen::VectorXd &amp;x, Eigen::VectorXd &amp;lambda, const <a class="el" href="structScalingFactors.html">ScalingFactors</a> &amp;factors)</td></tr>
<tr class="separator:a900ccac531085de01e8e3a60e2eca4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af3536735b8f4efc21e11a83b8062f5f2" id="r_af3536735b8f4efc21e11a83b8062f5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structResiduals.html">Residuals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a></td></tr>
<tr class="separator:af3536735b8f4efc21e11a83b8062f5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55da355d90e490435337a5427b3c0c" id="r_a5c55da355d90e490435337a5427b3c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseSolver.html">SparseSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c55da355d90e490435337a5427b3c0c">ls</a></td></tr>
<tr class="separator:a5c55da355d90e490435337a5427b3c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54987d081f0eebc91d6a0247c471d92a" id="r_a54987d081f0eebc91d6a0247c471d92a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a></td></tr>
<tr class="separator:a54987d081f0eebc91d6a0247c471d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957045b153c2587ced811544b5772410" id="r_a957045b153c2587ced811544b5772410"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a957045b153c2587ced811544b5772410">kappa</a></td></tr>
<tr class="separator:a957045b153c2587ced811544b5772410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a5e7d41b0f72ce616f99b03d4785a5" id="r_ac1a5e7d41b0f72ce616f99b03d4785a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1a5e7d41b0f72ce616f99b03d4785a5">tol</a></td></tr>
<tr class="separator:ac1a5e7d41b0f72ce616f99b03d4785a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c2594ea4f46d9be99f18a27b34a7d8" id="r_ad0c2594ea4f46d9be99f18a27b34a7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c2594ea4f46d9be99f18a27b34a7d8">max_iter</a></td></tr>
<tr class="separator:ad0c2594ea4f46d9be99f18a27b34a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981ecfeb17af8eebcb536c8ec5075e28" id="r_a981ecfeb17af8eebcb536c8ec5075e28"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="separator:a981ecfeb17af8eebcb536c8ec5075e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a3a2e1d4aa282ef28da6ca378d7bc" id="r_a120a3a2e1d4aa282ef28da6ca378d7bc"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a120a3a2e1d4aa282ef28da6ca378d7bc">x_old</a></td></tr>
<tr class="separator:a120a3a2e1d4aa282ef28da6ca378d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade64d46c893afea62c9c761d8c93991d" id="r_ade64d46c893afea62c9c761d8c93991d"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade64d46c893afea62c9c761d8c93991d">lambda_old</a></td></tr>
<tr class="separator:ade64d46c893afea62c9c761d8c93991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a3f9beb44ee2ba28b0d5cc8ea6edfb" id="r_ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a3f9beb44ee2ba28b0d5cc8ea6edfb">s_old</a></td></tr>
<tr class="separator:ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34388a63283d1d26ccd9b77f879c16b" id="r_ab34388a63283d1d26ccd9b77f879c16b"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34388a63283d1d26ccd9b77f879c16b">v_old</a></td></tr>
<tr class="separator:ab34388a63283d1d26ccd9b77f879c16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f8ae7257d8a77f3caa63b3de21588c" id="r_a31f8ae7257d8a77f3caa63b3de21588c"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f8ae7257d8a77f3caa63b3de21588c">w_old</a></td></tr>
<tr class="separator:a31f8ae7257d8a77f3caa63b3de21588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60db34cbbec5a679411c8ec9d25f2dcd" id="r_a60db34cbbec5a679411c8ec9d25f2dcd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60db34cbbec5a679411c8ec9d25f2dcd">tau_old</a></td></tr>
<tr class="separator:a60db34cbbec5a679411c8ec9d25f2dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64d7bec3101a6366409c58206d976d" id="r_afc64d7bec3101a6366409c58206d976d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc64d7bec3101a6366409c58206d976d">kappa_old</a></td></tr>
<tr class="separator:afc64d7bec3101a6366409c58206d976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d4563c64b404dc1c6a973f9b899508" id="r_af1d4563c64b404dc1c6a973f9b899508"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1d4563c64b404dc1c6a973f9b899508">n_slacks_old</a> = 0</td></tr>
<tr class="separator:af1d4563c64b404dc1c6a973f9b899508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6e2a7694ec8befa9470e1aa4acf438" id="r_a4c6e2a7694ec8befa9470e1aa4acf438"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c6e2a7694ec8befa9470e1aa4acf438">n_slacks</a> = 0</td></tr>
<tr class="separator:a4c6e2a7694ec8befa9470e1aa4acf438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9b941d7216d239af63eede001ab647" id="r_a6b9b941d7216d239af63eede001ab647"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b9b941d7216d239af63eede001ab647">warm_start</a> = false</td></tr>
<tr class="separator:a6b9b941d7216d239af63eede001ab647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b689456be5e57ddcadae9254dc35c4a" id="r_a8b689456be5e57ddcadae9254dc35c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b689456be5e57ddcadae9254dc35c4a">dual_vals</a></td></tr>
<tr class="separator:a8b689456be5e57ddcadae9254dc35c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a138d4376f21d730e110d0547af83b" id="r_a77a138d4376f21d730e110d0547af83b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a138d4376f21d730e110d0547af83b">primal_vals</a></td></tr>
<tr class="separator:a77a138d4376f21d730e110d0547af83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46689efc5c499d0e9b53b661e0a5405e" id="r_a46689efc5c499d0e9b53b661e0a5405e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46689efc5c499d0e9b53b661e0a5405e">objVal</a></td></tr>
<tr class="separator:a46689efc5c499d0e9b53b661e0a5405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for solving linear programming problems using an interior point method. </p>
<p>This class provides methods to convert linear programming problems to standard form, update residuals, solve augmented systems, and run the optimization process. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00174">174</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a365696b5a6356e7f9bc2d4b199fbc9f7" name="a365696b5a6356e7f9bc2d4b199fbc9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365696b5a6356e7f9bc2d4b199fbc9f7">&#9670;&#160;</a></span>IPSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IPSolver::IPSolver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00203">203</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  203</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2651221065511beedd53613296aaddcb" name="a2651221065511beedd53613296aaddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2651221065511beedd53613296aaddcb">&#9670;&#160;</a></span>convert_to_standard_form()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::convert_to_standard_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>sense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>As</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>bs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>cs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given linear programming problem to its standard form. </p>
<p>This function transforms the input linear programming problem defined by the matrices and vectors A, b, c, lb, ub, and sense into its standard form. The standard form is characterized by having all variables non-negative and all constraints as equalities. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00039">39</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   43</span>                                                                         {</div>
<div class="line"><span class="lineno">   44</span>    <span class="keyword">constexpr</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="lineno">   45</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> n = A.rows();</div>
<div class="line"><span class="lineno">   46</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> m = A.cols();</div>
<div class="line"><span class="lineno">   47</span> </div>
<div class="line"><span class="lineno">   48</span>    <span class="comment">// Fast input validation</span></div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">if</span> (b.size() != n || c.size() != m) {</div>
<div class="line"><span class="lineno">   50</span>        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Size mismatch in inputs&quot;</span>);</div>
<div class="line"><span class="lineno">   51</span>    }</div>
<div class="line"><span class="lineno">   52</span> </div>
<div class="line"><span class="lineno">   53</span>    <span class="comment">// Pre-calculate sizes in one pass</span></div>
<div class="line"><span class="lineno">   54</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> num_slacks = n - sense.sum();</div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordtype">int</span> n_free = 0;</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span>    <span class="comment">// Use char instead of bool for better performance</span></div>
<div class="line"><span class="lineno">   58</span>    std::vector&lt;char&gt; is_free(m);</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>    <span class="comment">// First pass: just count free variables and mark free vars</span></div>
<div class="line"><span class="lineno">   61</span>    <span class="comment">// This is faster than categorizing everything up front</span></div>
<div class="line"><span class="lineno">   62</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; ++i) {</div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordflow">if</span> (lb[i] == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; ub[i] == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">   64</span>            is_free[i] = 1;</div>
<div class="line"><span class="lineno">   65</span>            ++n_free;</div>
<div class="line"><span class="lineno">   66</span>        }</div>
<div class="line"><span class="lineno">   67</span>    }</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>    <span class="comment">// Preallocate output vectors</span></div>
<div class="line"><span class="lineno">   70</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> total_vars = m + n_free + num_slacks;</div>
<div class="line"><span class="lineno">   71</span>    cs.resize(total_vars);</div>
<div class="line"><span class="lineno">   72</span>    cs.head(m) = c;                     <span class="comment">// Copy original costs</span></div>
<div class="line"><span class="lineno">   73</span>    cs.tail(total_vars - m).setZero();  <span class="comment">// Zero out the rest</span></div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span>    <span class="comment">// Direct assignment is faster than copying</span></div>
<div class="line"><span class="lineno">   76</span>    bs = b;</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span>    <span class="comment">// Reserve exact space for triplets based on matrix structure</span></div>
<div class="line"><span class="lineno">   79</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> estimated_nnz =</div>
<div class="line"><span class="lineno">   80</span>        A.nonZeros() + n_free * (A.nonZeros() / m) + num_slacks;</div>
<div class="line"><span class="lineno">   81</span>    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets;</div>
<div class="line"><span class="lineno">   82</span>    triplets.reserve(estimated_nnz);</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    <span class="comment">// Process variables and construct matrix in a single pass</span></div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordtype">int</span> free_counter = 0;</div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; ++j) {</div>
<div class="line"><span class="lineno">   87</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> lj = lb[j];</div>
<div class="line"><span class="lineno">   88</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> uj = ub[j];</div>
<div class="line"><span class="lineno">   89</span> </div>
<div class="line"><span class="lineno">   90</span>        <span class="comment">// Process column j of the sparse matrix</span></div>
<div class="line"><span class="lineno">   91</span>        <span class="keywordflow">for</span> (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(A, j); it; ++it) {</div>
<div class="line"><span class="lineno">   92</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> row = it.row();</div>
<div class="line"><span class="lineno">   93</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> val = it.value();</div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span>            <span class="keywordflow">if</span> (is_free[j]) {</div>
<div class="line"><span class="lineno">   96</span>                <span class="comment">// Free variable: split into positive and negative parts</span></div>
<div class="line"><span class="lineno">   97</span>                triplets.emplace_back(row, j, val);</div>
<div class="line"><span class="lineno">   98</span>                triplets.emplace_back(row, m + free_counter, -val);</div>
<div class="line"><span class="lineno">   99</span>                cs[m + free_counter] = -c[j];</div>
<div class="line"><span class="lineno">  100</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lj == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; uj == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  101</span>                <span class="comment">// Already handled above</span></div>
<div class="line"><span class="lineno">  102</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  103</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(lj) &amp;&amp; std::isfinite(uj)) {</div>
<div class="line"><span class="lineno">  104</span>                <span class="comment">// Bounded variable</span></div>
<div class="line"><span class="lineno">  105</span>                triplets.emplace_back(row, j, val);</div>
<div class="line"><span class="lineno">  106</span>                bs[row] -= val * lj;</div>
<div class="line"><span class="lineno">  107</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lj == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; std::isfinite(uj)) {</div>
<div class="line"><span class="lineno">  108</span>                <span class="comment">// Upper bounded</span></div>
<div class="line"><span class="lineno">  109</span>                triplets.emplace_back(row, j, -val);</div>
<div class="line"><span class="lineno">  110</span>                bs[row] += val * uj;</div>
<div class="line"><span class="lineno">  111</span>                cs[j] = -c[j];</div>
<div class="line"><span class="lineno">  112</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(lj) &amp;&amp; uj == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  113</span>                <span class="comment">// Lower bounded</span></div>
<div class="line"><span class="lineno">  114</span>                triplets.emplace_back(row, j, val);</div>
<div class="line"><span class="lineno">  115</span>                bs[row] -= val * lj;</div>
<div class="line"><span class="lineno">  116</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  117</span>                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;unexpected bounds&quot;</span>);</div>
<div class="line"><span class="lineno">  118</span>            }</div>
<div class="line"><span class="lineno">  119</span>        }</div>
<div class="line"><span class="lineno">  120</span>        <span class="keywordflow">if</span> (is_free[j]) ++free_counter;</div>
<div class="line"><span class="lineno">  121</span>    }</div>
<div class="line"><span class="lineno">  122</span> </div>
<div class="line"><span class="lineno">  123</span>    <span class="comment">// Add slack variables efficiently</span></div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordtype">int</span> slack_counter = 0;</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line"><span class="lineno">  126</span>        <span class="keywordflow">if</span> (sense(i) == 0) {</div>
<div class="line"><span class="lineno">  127</span>            triplets.emplace_back(i, m + n_free + slack_counter++, 1.0);</div>
<div class="line"><span class="lineno">  128</span>        }</div>
<div class="line"><span class="lineno">  129</span>    }</div>
<div class="line"><span class="lineno">  130</span> </div>
<div class="line"><span class="lineno">  131</span>    <span class="comment">// Construct final sparse matrix efficiently</span></div>
<div class="line"><span class="lineno">  132</span>    As.resize(n, total_vars);</div>
<div class="line"><span class="lineno">  133</span>    As.reserve(estimated_nnz);  <span class="comment">// Reserve space before setting triplets</span></div>
<div class="line"><span class="lineno">  134</span>    As.setFromTriplets(triplets.begin(), triplets.end());</div>
<div class="line"><span class="lineno">  135</span>    As.makeCompressed();</div>
<div class="line"><span class="lineno">  136</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a981ecfeb17af8eebcb536c8ec5075e28"><div class="ttname"><a href="#a981ecfeb17af8eebcb536c8ec5075e28">IPSolver::infty</a></div><div class="ttdeci">double infty</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00180">IPSolver.h:180</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f6983d42c0a0af7344a9c7f9b79cdfe" name="a2f6983d42c0a0af7344a9c7f9b79cdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">&#9670;&#160;</a></span>convertToOptimizationData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOptimizationData.html">OptimizationData</a> IPSolver::convertToOptimizationData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structModelData.html">ModelData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>modelData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00799">799</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  800</span>                                {</div>
<div class="line"><span class="lineno">  801</span>    OptimizationData optData;</div>
<div class="line"><span class="lineno">  802</span> </div>
<div class="line"><span class="lineno">  803</span>    <span class="comment">// Convert SparseMatrix to Eigen::SparseMatrix using Eigen::Triplet</span></div>
<div class="line"><span class="lineno">  804</span>    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets;</div>
<div class="line"><span class="lineno">  805</span>    <span class="keyword">auto</span> sparseMatrix = modelData.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>;</div>
<div class="line"><span class="lineno">  806</span> </div>
<div class="line"><span class="lineno">  807</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#aa2ff8a7b473a5656481967750bd566aa">As</a> = modelData.<a class="code hl_variable" href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">A_sparse</a>.toEigenSparseMatrix();</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>    <span class="comment">// Iterate over the CRS format of SparseMatrix to build triplets</span></div>
<div class="line"><span class="lineno">  810</span>    <span class="comment">// for (int i = 0; i &lt; sparseMatrix.outerSize(); ++i) {</span></div>
<div class="line"><span class="lineno">  811</span>    <span class="comment">//    for (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(sparseMatrix, i);</span></div>
<div class="line"><span class="lineno">  812</span>    <span class="comment">//    it; ++it) {</span></div>
<div class="line"><span class="lineno">  813</span>    <span class="comment">//        triplets.push_back(Eigen::Triplet&lt;double&gt;(it.row(), it.col(),</span></div>
<div class="line"><span class="lineno">  814</span>    <span class="comment">//        it.value()));</span></div>
<div class="line"><span class="lineno">  815</span>    <span class="comment">//    }</span></div>
<div class="line"><span class="lineno">  816</span>    <span class="comment">//}</span></div>
<div class="line"><span class="lineno">  817</span>    <span class="comment">// Resize the Eigen sparse matrix</span></div>
<div class="line"><span class="lineno">  818</span>    <span class="comment">// optData.As.resize(sparseMatrix.num_rows, sparseMatrix.num_cols);</span></div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>    <span class="comment">// Set the values from the triplets</span></div>
<div class="line"><span class="lineno">  821</span>    <span class="comment">// optData.As.setFromTriplets(triplets.begin(), triplets.end());</span></div>
<div class="line"><span class="lineno">  822</span> </div>
<div class="line"><span class="lineno">  823</span>    <span class="comment">// Make the matrix compressed for efficient operations</span></div>
<div class="line"><span class="lineno">  824</span>    <span class="comment">// optData.As.makeCompressed();</span></div>
<div class="line"><span class="lineno">  825</span> </div>
<div class="line"><span class="lineno">  826</span>    <span class="comment">// Convert b to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  827</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">bs</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#aea9d2f5b3aa72a3af01c62c7cd9d81f2">b</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#aea9d2f5b3aa72a3af01c62c7cd9d81f2">b</a>.size());</div>
<div class="line"><span class="lineno">  828</span> </div>
<div class="line"><span class="lineno">  829</span>    <span class="comment">// Convert c to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  830</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#a5b82c8604e7c30d49e34be2b83f84705">cs</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#a9524df699303a08928c2424e50f0c212">c</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#a9524df699303a08928c2424e50f0c212">c</a>.size());</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span>    <span class="comment">// Convert lb to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  833</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#aaf56347389a91b3384bd9d65b5b2a7a7">lo</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#a80344318cbffc04660646ec38d3f7180">lb</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#a80344318cbffc04660646ec38d3f7180">lb</a>.size());</div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>    <span class="comment">// Convert ub to Eigen::VectorXd</span></div>
<div class="line"><span class="lineno">  836</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#aa4cf17b671a5017a0f5d9a9c42dea1c0">hi</a> = Eigen::VectorXd::Map(modelData.<a class="code hl_variable" href="structModelData.html#a3454e039aeac6532f64f87599813d962">ub</a>.data(), modelData.<a class="code hl_variable" href="structModelData.html#a3454e039aeac6532f64f87599813d962">ub</a>.size());</div>
<div class="line"><span class="lineno">  837</span> </div>
<div class="line"><span class="lineno">  838</span>    <span class="comment">// Convert sense to Eigen::VectorXd (mapping &#39;&lt;&#39; to 0, &#39;=&#39; to 1, &#39;&gt;&#39; to 0</span></div>
<div class="line"><span class="lineno">  839</span>    <span class="comment">// and flipping the corresponding row)</span></div>
<div class="line"><span class="lineno">  840</span>    optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>.resize(modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>.size());</div>
<div class="line"><span class="lineno">  841</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>.size(); ++i) {</div>
<div class="line"><span class="lineno">  842</span>        <span class="keywordflow">if</span> (modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>[i] == <span class="charliteral">&#39;&lt;&#39;</span>) {</div>
<div class="line"><span class="lineno">  843</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>[i] = 0.0;</div>
<div class="line"><span class="lineno">  844</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>[i] == <span class="charliteral">&#39;=&#39;</span>) {</div>
<div class="line"><span class="lineno">  845</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>[i] = 1.0;</div>
<div class="line"><span class="lineno">  846</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (modelData.<a class="code hl_variable" href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">sense</a>[i] == <span class="charliteral">&#39;&gt;&#39;</span>) {</div>
<div class="line"><span class="lineno">  847</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">sense</a>[i] = 0.0;</div>
<div class="line"><span class="lineno">  848</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">bs</a>[i] = -optData.<a class="code hl_variable" href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">bs</a>[i];</div>
<div class="line"><span class="lineno">  849</span>            optData.<a class="code hl_variable" href="structOptimizationData.html#aa2ff8a7b473a5656481967750bd566aa">As</a>.row(i) *= -1;  <span class="comment">// Flip the row for &#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  850</span>        }</div>
<div class="line"><span class="lineno">  851</span>    }</div>
<div class="line"><span class="lineno">  852</span> </div>
<div class="line"><span class="lineno">  853</span>    <span class="keywordflow">return</span> optData;</div>
<div class="line"><span class="lineno">  854</span>}</div>
<div class="ttc" id="astructModelData_html_a245b4a1967df894ba7ef7ed10a2c111a"><div class="ttname"><a href="structModelData.html#a245b4a1967df894ba7ef7ed10a2c111a">ModelData::A_sparse</a></div><div class="ttdeci">SparseMatrix A_sparse</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00225">Definitions.h:225</a></div></div>
<div class="ttc" id="astructModelData_html_a3454e039aeac6532f64f87599813d962"><div class="ttname"><a href="structModelData.html#a3454e039aeac6532f64f87599813d962">ModelData::ub</a></div><div class="ttdeci">std::vector&lt; double &gt; ub</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00230">Definitions.h:230</a></div></div>
<div class="ttc" id="astructModelData_html_a80344318cbffc04660646ec38d3f7180"><div class="ttname"><a href="structModelData.html#a80344318cbffc04660646ec38d3f7180">ModelData::lb</a></div><div class="ttdeci">std::vector&lt; double &gt; lb</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00229">Definitions.h:229</a></div></div>
<div class="ttc" id="astructModelData_html_a9524df699303a08928c2424e50f0c212"><div class="ttname"><a href="structModelData.html#a9524df699303a08928c2424e50f0c212">ModelData::c</a></div><div class="ttdeci">std::vector&lt; double &gt; c</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00228">Definitions.h:228</a></div></div>
<div class="ttc" id="astructModelData_html_ac23a00bb904bdff4445e27b1478f3805"><div class="ttname"><a href="structModelData.html#ac23a00bb904bdff4445e27b1478f3805">ModelData::sense</a></div><div class="ttdeci">std::vector&lt; char &gt; sense</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00227">Definitions.h:227</a></div></div>
<div class="ttc" id="astructModelData_html_aea9d2f5b3aa72a3af01c62c7cd9d81f2"><div class="ttname"><a href="structModelData.html#aea9d2f5b3aa72a3af01c62c7cd9d81f2">ModelData::b</a></div><div class="ttdeci">std::vector&lt; double &gt; b</div><div class="ttdef"><b>Definition</b> <a href="Definitions_8h_source.html#l00226">Definitions.h:226</a></div></div>
<div class="ttc" id="astructOptimizationData_html_a11c0e5839dd840148a8bdde9c92c283d"><div class="ttname"><a href="structOptimizationData.html#a11c0e5839dd840148a8bdde9c92c283d">OptimizationData::sense</a></div><div class="ttdeci">Eigen::VectorXd sense</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00041">IPSolver.h:41</a></div></div>
<div class="ttc" id="astructOptimizationData_html_a3d49a2b24845bf93e19f3bbcb6c3de41"><div class="ttname"><a href="structOptimizationData.html#a3d49a2b24845bf93e19f3bbcb6c3de41">OptimizationData::bs</a></div><div class="ttdeci">Eigen::VectorXd bs</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00037">IPSolver.h:37</a></div></div>
<div class="ttc" id="astructOptimizationData_html_a5b82c8604e7c30d49e34be2b83f84705"><div class="ttname"><a href="structOptimizationData.html#a5b82c8604e7c30d49e34be2b83f84705">OptimizationData::cs</a></div><div class="ttdeci">Eigen::VectorXd cs</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00038">IPSolver.h:38</a></div></div>
<div class="ttc" id="astructOptimizationData_html_aa2ff8a7b473a5656481967750bd566aa"><div class="ttname"><a href="structOptimizationData.html#aa2ff8a7b473a5656481967750bd566aa">OptimizationData::As</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; As</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00036">IPSolver.h:36</a></div></div>
<div class="ttc" id="astructOptimizationData_html_aa4cf17b671a5017a0f5d9a9c42dea1c0"><div class="ttname"><a href="structOptimizationData.html#aa4cf17b671a5017a0f5d9a9c42dea1c0">OptimizationData::hi</a></div><div class="ttdeci">Eigen::VectorXd hi</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00040">IPSolver.h:40</a></div></div>
<div class="ttc" id="astructOptimizationData_html_aaf56347389a91b3384bd9d65b5b2a7a7"><div class="ttname"><a href="structOptimizationData.html#aaf56347389a91b3384bd9d65b5b2a7a7">OptimizationData::lo</a></div><div class="ttdeci">Eigen::VectorXd lo</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00039">IPSolver.h:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6ab576c321bd6a0506d9c5bf8362f1a" name="ad6ab576c321bd6a0506d9c5bf8362f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ab576c321bd6a0506d9c5bf8362f1a">&#9670;&#160;</a></span>convertToSparseDiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; double &gt; IPSolver::convertToSparseDiagonal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a dense vector to a sparse diagonal matrix. </p>
<p>This function takes a dense vector and converts it into a sparse diagonal matrix. The resulting sparse matrix has non-zero values only on its diagonal, where the values are taken from the input vector. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00023">23</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   24</span>                              {</div>
<div class="line"><span class="lineno">   25</span>    Eigen::SparseMatrix&lt;double&gt; mat(vec.size(), vec.size());</div>
<div class="line"><span class="lineno">   26</span>    mat = vec.asDiagonal();</div>
<div class="line"><span class="lineno">   27</span>    <span class="keywordflow">return</span> mat;</div>
<div class="line"><span class="lineno">   28</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a61f035c65c660c2f0fcddc687388fb0d" name="a61f035c65c660c2f0fcddc687388fb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f035c65c660c2f0fcddc687388fb0d">&#9670;&#160;</a></span>getDuals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; IPSolver::getDuals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00198">198</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  198</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="#a8b689456be5e57ddcadae9254dc35c4a">dual_vals</a>; }</div>
<div class="ttc" id="aclassIPSolver_html_a8b689456be5e57ddcadae9254dc35c4a"><div class="ttname"><a href="#a8b689456be5e57ddcadae9254dc35c4a">IPSolver::dual_vals</a></div><div class="ttdeci">std::vector&lt; double &gt; dual_vals</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00194">IPSolver.h:194</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aac6e8605bf4d41ddd7bf4f8f4384c0a1" name="aac6e8605bf4d41ddd7bf4f8f4384c0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6e8605bf4d41ddd7bf4f8f4384c0a1">&#9670;&#160;</a></span>getObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::getObjective </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00200">200</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  200</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="#a46689efc5c499d0e9b53b661e0a5405e">objVal</a>; }</div>
<div class="ttc" id="aclassIPSolver_html_a46689efc5c499d0e9b53b661e0a5405e"><div class="ttname"><a href="#a46689efc5c499d0e9b53b661e0a5405e">IPSolver::objVal</a></div><div class="ttdeci">double objVal</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00196">IPSolver.h:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a87b4972a25d69cc80c2a5f4676c1aa93" name="a87b4972a25d69cc80c2a5f4676c1aa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b4972a25d69cc80c2a5f4676c1aa93">&#9670;&#160;</a></span>getPrimals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; IPSolver::getPrimals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00199">199</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  199</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="#a77a138d4376f21d730e110d0547af83b">primal_vals</a>; }</div>
<div class="ttc" id="aclassIPSolver_html_a77a138d4376f21d730e110d0547af83b"><div class="ttname"><a href="#a77a138d4376f21d730e110d0547af83b">IPSolver::primal_vals</a></div><div class="ttdeci">std::vector&lt; double &gt; primal_vals</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00195">IPSolver.h:195</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a16c38201e3fc179e9265a82e67510679" name="a16c38201e3fc179e9265a82e67510679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c38201e3fc179e9265a82e67510679">&#9670;&#160;</a></span>max_alpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::max_alpha </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dtau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dkappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum step size (alpha) that can be taken along the direction of the search vectors. </p>
<p>This function calculates the maximum allowable step size (alpha) that can be taken along the direction of the search vectors (dx, dv, ds, dw) without violating certain constraints. It considers the current values of the variables (x, v, s, w) and their respective search directions. Additionally, it takes into account the step sizes for tau and kappa. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00398">398</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  403</span>                                          {</div>
<div class="line"><span class="lineno">  404</span>    <span class="comment">// Initialize alpha with first scalar check</span></div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordtype">double</span> alpha = (dtau &lt; 0) ? (-<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> / dtau) : 1.0;</div>
<div class="line"><span class="lineno">  406</span> </div>
<div class="line"><span class="lineno">  407</span>    <span class="comment">// Check kappa condition and update alpha if needed</span></div>
<div class="line"><span class="lineno">  408</span>    <span class="keywordflow">if</span> (dkappa &lt; 0) {</div>
<div class="line"><span class="lineno">  409</span>        <span class="keywordtype">double</span> alpha_kappa = -<a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> / dkappa;</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">if</span> (alpha_kappa &lt; alpha) {</div>
<div class="line"><span class="lineno">  411</span>            alpha = alpha_kappa;</div>
<div class="line"><span class="lineno">  412</span>        }</div>
<div class="line"><span class="lineno">  413</span>    }</div>
<div class="line"><span class="lineno">  414</span> </div>
<div class="line"><span class="lineno">  415</span>    <span class="comment">// Efficiently compute and update minimum alpha for each vector pair</span></div>
<div class="line"><span class="lineno">  416</span>    <span class="keywordtype">double</span> potential_alpha = <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(x, dx);</div>
<div class="line"><span class="lineno">  417</span>    <span class="keywordflow">if</span> (potential_alpha &lt; alpha) alpha = potential_alpha;</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>    potential_alpha = <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(v, dv);</div>
<div class="line"><span class="lineno">  420</span>    <span class="keywordflow">if</span> (potential_alpha &lt; alpha) alpha = potential_alpha;</div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span>    potential_alpha = <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(s, ds);</div>
<div class="line"><span class="lineno">  423</span>    <span class="keywordflow">if</span> (potential_alpha &lt; alpha) alpha = potential_alpha;</div>
<div class="line"><span class="lineno">  424</span> </div>
<div class="line"><span class="lineno">  425</span>    potential_alpha = <a class="code hl_function" href="#add3037642e4e2090f62e90d9df5eee9f">max_alpha_single</a>(w, dw);</div>
<div class="line"><span class="lineno">  426</span>    <span class="keywordflow">if</span> (potential_alpha &lt; alpha) alpha = potential_alpha;</div>
<div class="line"><span class="lineno">  427</span> </div>
<div class="line"><span class="lineno">  428</span>    <span class="keywordflow">return</span> alpha;</div>
<div class="line"><span class="lineno">  429</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a54987d081f0eebc91d6a0247c471d92a"><div class="ttname"><a href="#a54987d081f0eebc91d6a0247c471d92a">IPSolver::tau</a></div><div class="ttdeci">double tau</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00178">IPSolver.h:178</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a957045b153c2587ced811544b5772410"><div class="ttname"><a href="#a957045b153c2587ced811544b5772410">IPSolver::kappa</a></div><div class="ttdeci">double kappa</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00178">IPSolver.h:178</a></div></div>
<div class="ttc" id="aclassIPSolver_html_add3037642e4e2090f62e90d9df5eee9f"><div class="ttname"><a href="#add3037642e4e2090f62e90d9df5eee9f">IPSolver::max_alpha_single</a></div><div class="ttdeci">double max_alpha_single(const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv)</div><div class="ttdoc">Computes the maximum step size (alpha) for a single direction vector.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00354">IPSolver.cpp:354</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph.png" border="0" usemap="#aclassIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph" alt=""/></div>
<map name="aclassIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph" id="aclassIPSolver_a16c38201e3fc179e9265a82e67510679_cgraph">
<area shape="rect" title="Computes the maximum step size (alpha) that can be taken along the direction of the search vectors." alt="" coords="5,13,145,38"/>
<area shape="rect" href="classIPSolver.html#add3037642e4e2090f62e90d9df5eee9f" title="Computes the maximum step size (alpha) for a single direction vector." alt="" coords="193,5,332,46"/>
<area shape="poly" title=" " alt="" coords="145,23,177,23,177,28,145,28"/>
</map>
</div>

</div>
</div>
<a id="add3037642e4e2090f62e90d9df5eee9f" name="add3037642e4e2090f62e90d9df5eee9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3037642e4e2090f62e90d9df5eee9f">&#9670;&#160;</a></span>max_alpha_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::max_alpha_single </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum step size (alpha) for a single direction vector. </p>
<p>This function calculates the maximum allowable step size (alpha) such that the updated vector (v + alpha * dv) remains non-negative. It iterates through each element of the input vectors <code>v</code> and <code>dv</code>, and for each negative element in <code>dv</code>, it computes a potential alpha value. The minimum of these potential alpha values is returned as the result. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00354">354</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  355</span>                                                           {</div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordtype">double</span> alpha = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>    <span class="comment">// Get direct access to data</span></div>
<div class="line"><span class="lineno">  359</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *v_data = v.data();</div>
<div class="line"><span class="lineno">  360</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *dv_data = dv.data();</div>
<div class="line"><span class="lineno">  361</span>    <span class="keyword">const</span> Eigen::Index size = v.size();</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span>    <span class="comment">// Process in chunks for better cache utilization</span></div>
<div class="line"><span class="lineno">  364</span>    <span class="keyword">constexpr</span> Eigen::Index CHUNK_SIZE = 4;</div>
<div class="line"><span class="lineno">  365</span>    Eigen::Index i = 0;</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>    <span class="comment">// Process main chunks</span></div>
<div class="line"><span class="lineno">  368</span>    <span class="keywordflow">for</span> (; i + CHUNK_SIZE &lt;= size; i += CHUNK_SIZE) {</div>
<div class="line"><span class="lineno">  369</span>        <span class="keywordflow">if</span> (dv_data[i] &lt; 0) alpha = std::min(alpha, -v_data[i] / dv_data[i]);</div>
<div class="line"><span class="lineno">  370</span>        <span class="keywordflow">if</span> (dv_data[i + 1] &lt; 0)</div>
<div class="line"><span class="lineno">  371</span>            alpha = std::min(alpha, -v_data[i + 1] / dv_data[i + 1]);</div>
<div class="line"><span class="lineno">  372</span>        <span class="keywordflow">if</span> (dv_data[i + 2] &lt; 0)</div>
<div class="line"><span class="lineno">  373</span>            alpha = std::min(alpha, -v_data[i + 2] / dv_data[i + 2]);</div>
<div class="line"><span class="lineno">  374</span>        <span class="keywordflow">if</span> (dv_data[i + 3] &lt; 0)</div>
<div class="line"><span class="lineno">  375</span>            alpha = std::min(alpha, -v_data[i + 3] / dv_data[i + 3]);</div>
<div class="line"><span class="lineno">  376</span>    }</div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="line"><span class="lineno">  378</span>    <span class="comment">// Handle remaining elements</span></div>
<div class="line"><span class="lineno">  379</span>    <span class="keywordflow">for</span> (; i &lt; size; ++i) {</div>
<div class="line"><span class="lineno">  380</span>        <span class="keywordflow">if</span> (dv_data[i] &lt; 0) {</div>
<div class="line"><span class="lineno">  381</span>            alpha = std::min(alpha, -v_data[i] / dv_data[i]);</div>
<div class="line"><span class="lineno">  382</span>        }</div>
<div class="line"><span class="lineno">  383</span>    }</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">return</span> alpha;</div>
<div class="line"><span class="lineno">  386</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac30d61bc3f60ab5545cbaf698cecc1d7" name="ac30d61bc3f60ab5545cbaf698cecc1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d61bc3f60ab5545cbaf698cecc1d7">&#9670;&#160;</a></span>ruiz_scaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structScalingFactors.html">ScalingFactors</a> IPSolver::ruiz_scaling </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc02635739446925971f247ee90227ad" name="acc02635739446925971f247ee90227ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc02635739446925971f247ee90227ad">&#9670;&#160;</a></span>run_optimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::run_optimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structModelData.html">ModelData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the optimization process on the given model data. </p>
<p>This function performs an optimization using an interior point method (IPM) on the provided model data. It converts the model data to a standard form, initializes necessary variables, and iteratively solves the optimization problem until convergence or the maximum number of iterations is reached. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00440">440</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  440</span>                                                                  {</div>
<div class="line"><span class="lineno">  441</span>    <span class="comment">// Get optimization data</span></div>
<div class="line"><span class="lineno">  442</span>    <span class="keyword">auto</span> componentes = <a class="code hl_function" href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">convertToOptimizationData</a>(model);</div>
<div class="line"><span class="lineno">  443</span>    <span class="keyword">const</span> Eigen::SparseMatrix&lt;double&gt; &amp;As = componentes.As;</div>
<div class="line"><span class="lineno">  444</span>    <span class="keyword">const</span> Eigen::VectorXd &amp;bs = componentes.bs;</div>
<div class="line"><span class="lineno">  445</span>    <span class="keyword">const</span> Eigen::VectorXd &amp;cs = componentes.cs;</div>
<div class="line"><span class="lineno">  446</span>    <span class="keyword">const</span> Eigen::VectorXd &amp;lo = componentes.lo;</div>
<div class="line"><span class="lineno">  447</span>    <span class="keyword">const</span> Eigen::VectorXd &amp;hi = componentes.hi;</div>
<div class="line"><span class="lineno">  448</span>    <span class="keyword">const</span> Eigen::VectorXd &amp;sense = componentes.sense;</div>
<div class="line"><span class="lineno">  449</span> </div>
<div class="line"><span class="lineno">  450</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> nv_orig = cs.size();</div>
<div class="line"><span class="lineno">  451</span> </div>
<div class="line"><span class="lineno">  452</span>    <span class="comment">// Convert to standard form</span></div>
<div class="line"><span class="lineno">  453</span>    Eigen::SparseMatrix&lt;double&gt; A;</div>
<div class="line"><span class="lineno">  454</span>    Eigen::VectorXd b, c;</div>
<div class="line"><span class="lineno">  455</span>    <a class="code hl_function" href="#a2651221065511beedd53613296aaddcb">convert_to_standard_form</a>(As, bs, cs, lo, hi, sense, A, b, c);</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> n = A.cols();</div>
<div class="line"><span class="lineno">  458</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> m = A.rows();</div>
<div class="line"><span class="lineno">  459</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="#ad0c2594ea4f46d9be99f18a27b34a7d8">max_iter</a> = 500;</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span>    <span class="comment">// Initialize primal/dual variables</span></div>
<div class="line"><span class="lineno">  462</span>    Eigen::VectorXd x = Eigen::VectorXd::Ones(n);</div>
<div class="line"><span class="lineno">  463</span>    Eigen::VectorXd lambda = Eigen::VectorXd::Zero(m);</div>
<div class="line"><span class="lineno">  464</span>    Eigen::VectorXd s = Eigen::VectorXd::Ones(n);</div>
<div class="line"><span class="lineno">  465</span>    <a class="code hl_variable" href="#a6b9b941d7216d239af63eede001ab647">warm_start</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  466</span>    <a class="code hl_variable" href="#af1d4563c64b404dc1c6a973f9b899508">n_slacks_old</a> = <a class="code hl_variable" href="#a4c6e2a7694ec8befa9470e1aa4acf438">n_slacks</a>;</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>    <span class="comment">// Combine loops to determine finite upper bounds (hi) and record their</span></div>
<div class="line"><span class="lineno">  469</span>    <span class="comment">// indices and values</span></div>
<div class="line"><span class="lineno">  470</span>    <span class="keywordtype">double</span> <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="lineno">  471</span>    std::vector&lt;int&gt; indices;</div>
<div class="line"><span class="lineno">  472</span>    std::vector&lt;double&gt; ubv_std;</div>
<div class="line"><span class="lineno">  473</span>    indices.reserve(hi.size());</div>
<div class="line"><span class="lineno">  474</span>    ubv_std.reserve(hi.size());</div>
<div class="line"><span class="lineno">  475</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; hi.size(); ++i) {</div>
<div class="line"><span class="lineno">  476</span>        <span class="keywordflow">if</span> (hi[i] != <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  477</span>            indices.push_back(i);</div>
<div class="line"><span class="lineno">  478</span>            ubv_std.push_back(hi[i]);</div>
<div class="line"><span class="lineno">  479</span>        }</div>
<div class="line"><span class="lineno">  480</span>    }</div>
<div class="line"><span class="lineno">  481</span>    Eigen::VectorXi ubi = Eigen::Map&lt;Eigen::VectorXi&gt;(</div>
<div class="line"><span class="lineno">  482</span>        indices.data(), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(indices.size()));</div>
<div class="line"><span class="lineno">  483</span>    Eigen::VectorXd ubv = Eigen::Map&lt;Eigen::VectorXd&gt;(</div>
<div class="line"><span class="lineno">  484</span>        ubv_std.data(), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ubv_std.size()));</div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span>    <span class="comment">// Initialize additional vectors</span></div>
<div class="line"><span class="lineno">  487</span>    Eigen::VectorXd v = Eigen::VectorXd::Ones(ubv.size());</div>
<div class="line"><span class="lineno">  488</span>    Eigen::VectorXd w = Eigen::VectorXd::Ones(ubv.size());</div>
<div class="line"><span class="lineno">  489</span>    <span class="keywordtype">double</span> <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> = 1.0, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> = 1.0;</div>
<div class="line"><span class="lineno">  490</span>    Eigen::VectorXd regP = Eigen::VectorXd::Ones(n);</div>
<div class="line"><span class="lineno">  491</span>    Eigen::VectorXd regD = Eigen::VectorXd::Ones(m);</div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordtype">double</span> regG = 1.0;</div>
<div class="line"><span class="lineno">  493</span> </div>
<div class="line"><span class="lineno">  494</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.reset();</div>
<div class="line"><span class="lineno">  495</span>    <a class="code hl_function" href="#aac549fa9ef9fd8c98dc9262550a81f4d">start_linear_solver</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, A);</div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> nc = A.rows();</div>
<div class="line"><span class="lineno">  498</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> nv = A.cols();</div>
<div class="line"><span class="lineno">  499</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> nu = ubi.size();</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span>    <span class="comment">// Preallocate vectors (reuse storage in each iteration)</span></div>
<div class="line"><span class="lineno">  502</span>    Eigen::VectorXd delta_x = Eigen::VectorXd::Zero(nv);</div>
<div class="line"><span class="lineno">  503</span>    Eigen::VectorXd delta_y = Eigen::VectorXd::Zero(nc);</div>
<div class="line"><span class="lineno">  504</span>    Eigen::VectorXd delta_z = Eigen::VectorXd::Zero(nu);</div>
<div class="line"><span class="lineno">  505</span>    Residuals <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>;</div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> r_min = std::sqrt(std::numeric_limits&lt;double&gt;::epsilon());</div>
<div class="line"><span class="lineno">  508</span>    <span class="keywordtype">int</span> ncor = 0;</div>
<div class="line"><span class="lineno">  509</span>    <span class="keywordtype">double</span> _p, _d, _g, mu;</div>
<div class="line"><span class="lineno">  510</span>    <span class="keywordtype">double</span> alpha, alpha_c, alpha_;</div>
<div class="line"><span class="lineno">  511</span>    <span class="keywordtype">double</span> beta, gamma, damping, oneMinusAlpha;</div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordtype">double</span> mu_l, mu_u, taukappa, t0;</div>
<div class="line"><span class="lineno">  513</span>    Eigen::VectorXd theta_vw, theta_xs;</div>
<div class="line"><span class="lineno">  514</span>    Eigen::VectorXd Delta_x = Eigen::VectorXd::Zero(x.size());</div>
<div class="line"><span class="lineno">  515</span>    Eigen::VectorXd Delta_lambda = Eigen::VectorXd::Zero(lambda.size());</div>
<div class="line"><span class="lineno">  516</span>    Eigen::VectorXd Delta_w = Eigen::VectorXd::Zero(w.size());</div>
<div class="line"><span class="lineno">  517</span>    Eigen::VectorXd Delta_s = Eigen::VectorXd::Zero(s.size());</div>
<div class="line"><span class="lineno">  518</span>    Eigen::VectorXd Delta_v = Eigen::VectorXd::Zero(v.size());</div>
<div class="line"><span class="lineno">  519</span>    <span class="keywordtype">double</span> Delta_tau = 0.0, Delta_kappa = 0.0;</div>
<div class="line"><span class="lineno">  520</span>    Eigen::VectorXd Delta_x_c = Eigen::VectorXd::Zero(x.size());</div>
<div class="line"><span class="lineno">  521</span>    Eigen::VectorXd Delta_lambda_c = Eigen::VectorXd::Zero(lambda.size());</div>
<div class="line"><span class="lineno">  522</span>    Eigen::VectorXd Delta_w_c = Eigen::VectorXd::Zero(w.size());</div>
<div class="line"><span class="lineno">  523</span>    Eigen::VectorXd Delta_s_c = Eigen::VectorXd::Zero(s.size());</div>
<div class="line"><span class="lineno">  524</span>    Eigen::VectorXd Delta_v_c = Eigen::VectorXd::Zero(v.size());</div>
<div class="line"><span class="lineno">  525</span>    <span class="keywordtype">double</span> Delta_tau_c = 0.0, Delta_kappa_c = 0.0;</div>
<div class="line"><span class="lineno">  526</span>    Eigen::VectorXd xs, vw, t_xs, t_vw;</div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordtype">double</span> delta_0, bl_dot_lambda;</div>
<div class="line"><span class="lineno">  528</span>    <span class="keywordtype">bool</span> saved_interior_solution_bool = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>    <span class="comment">// Adaptive tolerance parameters</span></div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordtype">double</span> adaptive_tol = 1e-9;</div>
<div class="line"><span class="lineno">  532</span> </div>
<div class="line"><span class="lineno">  533</span>    <span class="comment">// Main optimization loop</span></div>
<div class="line"><span class="lineno">  534</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; <a class="code hl_variable" href="#ad0c2594ea4f46d9be99f18a27b34a7d8">max_iter</a>; ++k) {</div>
<div class="line"><span class="lineno">  535</span>        ncor = 0;</div>
<div class="line"><span class="lineno">  536</span>        beta = 0.1;</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  538</span>        <span class="comment">// Zero out temporary vectors (reuse allocated memory)</span></div>
<div class="line"><span class="lineno">  539</span>        delta_x.setZero();</div>
<div class="line"><span class="lineno">  540</span>        delta_y.setZero();</div>
<div class="line"><span class="lineno">  541</span>        delta_z.setZero();</div>
<div class="line"><span class="lineno">  542</span>        Delta_x.setZero();</div>
<div class="line"><span class="lineno">  543</span>        Delta_lambda.setZero();</div>
<div class="line"><span class="lineno">  544</span>        Delta_w.setZero();</div>
<div class="line"><span class="lineno">  545</span>        Delta_s.setZero();</div>
<div class="line"><span class="lineno">  546</span>        Delta_v.setZero();</div>
<div class="line"><span class="lineno">  547</span>        Delta_tau = 0.0;</div>
<div class="line"><span class="lineno">  548</span>        Delta_kappa = 0.0;</div>
<div class="line"><span class="lineno">  549</span> </div>
<div class="line"><span class="lineno">  550</span>        <span class="comment">// Update residuals and compute centrality measure</span></div>
<div class="line"><span class="lineno">  551</span>        <a class="code hl_function" href="#a1f22b1985e02e839ff3b2791a0389865">update_residuals</a>(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>, x, lambda, s, v, w, A, b, c, ubv, ubi, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>,</div>
<div class="line"><span class="lineno">  552</span>                         <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>);</div>
<div class="line"><span class="lineno">  553</span>        mu = (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> + x.dot(s)) / (n + nu + 1.0);</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>        <span class="comment">// Compute norms for convergence criteria (using Eigen’s vectorized norm</span></div>
<div class="line"><span class="lineno">  556</span>        <span class="comment">// computations)</span></div>
<div class="line"><span class="lineno">  557</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> rp_norm = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rp.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  558</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> ru_norm = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.ru.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  559</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> rd_norm = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rd.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  560</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> b_norm = b.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  561</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> ubv_norm = ubv.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  562</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> c_norm = c.lpNorm&lt;Eigen::Infinity&gt;();</div>
<div class="line"><span class="lineno">  563</span> </div>
<div class="line"><span class="lineno">  564</span>        <span class="comment">// Combined residual computations</span></div>
<div class="line"><span class="lineno">  565</span>        bl_dot_lambda = b.dot(lambda) - ubv.dot(w);</div>
<div class="line"><span class="lineno">  566</span>        _p = std::max(rp_norm / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * (1.0 + b_norm)),</div>
<div class="line"><span class="lineno">  567</span>                      ru_norm / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * (1.0 + ubv_norm)));</div>
<div class="line"><span class="lineno">  568</span>        _d = rd_norm / (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * (1.0 + c_norm));</div>
<div class="line"><span class="lineno">  569</span>        _g = std::abs(c.dot(x) - bl_dot_lambda) /</div>
<div class="line"><span class="lineno">  570</span>             (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> + std::abs(bl_dot_lambda));</div>
<div class="line"><span class="lineno">  571</span> </div>
<div class="line"><span class="lineno">  572</span>        <span class="comment">// Save interior solution if conditions are met</span></div>
<div class="line"><span class="lineno">  573</span>        <span class="comment">// if (!saved_interior_solution_bool &amp;&amp;</span></div>
<div class="line"><span class="lineno">  574</span>        <span class="comment">//     (_d &lt;= adaptive_tol &amp;&amp; _g &lt;= adaptive_tol * 2)) {</span></div>
<div class="line"><span class="lineno">  575</span>        <span class="comment">//     save_interior_solution(x, lambda, w, s, v, tau, kappa);</span></div>
<div class="line"><span class="lineno">  576</span>        <span class="comment">//     saved_interior_solution_bool = true;</span></div>
<div class="line"><span class="lineno">  577</span>        <span class="comment">//     warm_start = true;</span></div>
<div class="line"><span class="lineno">  578</span>        <span class="comment">// }</span></div>
<div class="line"><span class="lineno">  579</span>        <span class="keywordflow">if</span> (_d &lt;= adaptive_tol &amp;&amp; _g &lt;= <a class="code hl_variable" href="#ac1a5e7d41b0f72ce616f99b03d4785a5">tol</a>) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  580</span>        <span class="comment">// adaptive_tol = std::max(min_tol, adaptive_tol * scale_factor);</span></div>
<div class="line"><span class="lineno">  581</span> </div>
<div class="line"><span class="lineno">  582</span>        <span class="comment">// Compute scaling factors</span></div>
<div class="line"><span class="lineno">  583</span>        theta_vw = w.cwiseQuotient(v);</div>
<div class="line"><span class="lineno">  584</span>        theta_xs = s.cwiseQuotient(x);</div>
<div class="line"><span class="lineno">  585</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi.size(); ++i) {</div>
<div class="line"><span class="lineno">  586</span>            theta_xs[ubi[i]] += theta_vw[i];</div>
<div class="line"><span class="lineno">  587</span>        }</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>        <span class="comment">// Update regularization dynamically (reuse regP/regD to avoid extra</span></div>
<div class="line"><span class="lineno">  590</span>        <span class="comment">// allocation)</span></div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> attempt = 0; attempt &lt; 3; ++attempt) {</div>
<div class="line"><span class="lineno">  592</span>            regP = (regP / 10.0).cwiseMax(r_min);</div>
<div class="line"><span class="lineno">  593</span>            regD = (regD / 10.0).cwiseMax(r_min);</div>
<div class="line"><span class="lineno">  594</span>            regG = std::max(r_min, regG / 10.0);</div>
<div class="line"><span class="lineno">  595</span>            <span class="keywordflow">if</span> (<a class="code hl_function" href="#a22f7028c11d89b7986357f004f269924">update_linear_solver</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_xs, regP, regD) == 0) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  596</span>            regP *= 100.0;</div>
<div class="line"><span class="lineno">  597</span>            regD *= 100.0;</div>
<div class="line"><span class="lineno">  598</span>            regG *= 100.0;</div>
<div class="line"><span class="lineno">  599</span>        }</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>        <span class="comment">// Solve the augmented system</span></div>
<div class="line"><span class="lineno">  602</span>        <a class="code hl_function" href="#a10d79c906c9f170d975b9404e793a14e">solve_augsys</a>(delta_x, delta_y, delta_z, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, ubi, b, c, ubv);</div>
<div class="line"><span class="lineno">  603</span>        delta_0 = regG + <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> / <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> - delta_x.dot(c) + delta_y.dot(b) -</div>
<div class="line"><span class="lineno">  604</span>                  delta_z.dot(ubv);</div>
<div class="line"><span class="lineno">  605</span> </div>
<div class="line"><span class="lineno">  606</span>        <span class="comment">// First Newton solve</span></div>
<div class="line"><span class="lineno">  607</span>        <a class="code hl_function" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a>(Delta_x, Delta_lambda, Delta_w, Delta_s, Delta_v,</div>
<div class="line"><span class="lineno">  608</span>                            Delta_tau, Delta_kappa, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, b, c, ubi,</div>
<div class="line"><span class="lineno">  609</span>                            ubv, delta_x, delta_y, delta_z, delta_0, x, lambda,</div>
<div class="line"><span class="lineno">  610</span>                            w, s, v, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rp, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.ru, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rd, <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rg,</div>
<div class="line"><span class="lineno">  611</span>                            -x.cwiseProduct(s), -v.cwiseProduct(w),</div>
<div class="line"><span class="lineno">  612</span>                            -<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>);</div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>        alpha = <a class="code hl_function" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a>(x, Delta_x, v, Delta_v, s, Delta_s, w, Delta_w, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>,</div>
<div class="line"><span class="lineno">  615</span>                          Delta_tau, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Delta_kappa);</div>
<div class="line"><span class="lineno">  616</span>        oneMinusAlpha = 1.0 - alpha;</div>
<div class="line"><span class="lineno">  617</span>        gamma = std::max(</div>
<div class="line"><span class="lineno">  618</span>            oneMinusAlpha * oneMinusAlpha * std::min(beta, oneMinusAlpha), 0.1);</div>
<div class="line"><span class="lineno">  619</span>        damping = 1.0 - gamma;</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>        <span class="comment">// Second (damped) Newton solve</span></div>
<div class="line"><span class="lineno">  622</span>        <a class="code hl_function" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a>(</div>
<div class="line"><span class="lineno">  623</span>            Delta_x, Delta_lambda, Delta_w, Delta_s, Delta_v, Delta_tau,</div>
<div class="line"><span class="lineno">  624</span>            Delta_kappa, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, b, c, ubi, ubv, delta_x, delta_y,</div>
<div class="line"><span class="lineno">  625</span>            delta_z, delta_0, x, lambda, w, s, v, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rp,</div>
<div class="line"><span class="lineno">  626</span>            damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.ru, damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rd, damping * <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rg,</div>
<div class="line"><span class="lineno">  627</span>            (-x.cwiseProduct(s)).array() + (gamma * mu) -</div>
<div class="line"><span class="lineno">  628</span>                Delta_x.cwiseProduct(Delta_s).array(),</div>
<div class="line"><span class="lineno">  629</span>            (-v.cwiseProduct(w)).array() + (gamma * mu) -</div>
<div class="line"><span class="lineno">  630</span>                Delta_v.cwiseProduct(Delta_w).array(),</div>
<div class="line"><span class="lineno">  631</span>            (-<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>) + (gamma * mu) - Delta_tau * Delta_kappa);</div>
<div class="line"><span class="lineno">  632</span> </div>
<div class="line"><span class="lineno">  633</span>        alpha = <a class="code hl_function" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a>(x, Delta_x, v, Delta_v, s, Delta_s, w, Delta_w, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>,</div>
<div class="line"><span class="lineno">  634</span>                          Delta_tau, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Delta_kappa);</div>
<div class="line"><span class="lineno">  635</span> </div>
<div class="line"><span class="lineno">  636</span>        <span class="comment">// High-order correction steps</span></div>
<div class="line"><span class="lineno">  637</span>        <span class="keywordflow">while</span> (ncor &lt;= 2 &amp;&amp; alpha &lt; 0.9995) {</div>
<div class="line"><span class="lineno">  638</span>            ncor++;</div>
<div class="line"><span class="lineno">  639</span>            alpha_ = std::min(1.0, 2.0 * alpha);</div>
<div class="line"><span class="lineno">  640</span>            mu_l = beta * mu * gamma;</div>
<div class="line"><span class="lineno">  641</span>            mu_u = gamma * mu / beta;</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>            xs = x + alpha_ * Delta_x;</div>
<div class="line"><span class="lineno">  644</span>            xs.array() *= (s + alpha_ * Delta_s).array();</div>
<div class="line"><span class="lineno">  645</span>            vw = v + alpha_ * Delta_v;</div>
<div class="line"><span class="lineno">  646</span>            vw.array() *= (w + alpha_ * Delta_w).array();</div>
<div class="line"><span class="lineno">  647</span> </div>
<div class="line"><span class="lineno">  648</span>            t_xs =</div>
<div class="line"><span class="lineno">  649</span>                (xs.array() &lt; mu_l)</div>
<div class="line"><span class="lineno">  650</span>                    .select(mu_l - xs.array(),</div>
<div class="line"><span class="lineno">  651</span>                            (xs.array() &gt; mu_u).select(mu_u - xs.array(), 0.0));</div>
<div class="line"><span class="lineno">  652</span>            t_vw =</div>
<div class="line"><span class="lineno">  653</span>                (vw.array() &lt; mu_l)</div>
<div class="line"><span class="lineno">  654</span>                    .select(mu_l - vw.array(),</div>
<div class="line"><span class="lineno">  655</span>                            (vw.array() &gt; mu_u).select(mu_u - vw.array(), 0.0));</div>
<div class="line"><span class="lineno">  656</span> </div>
<div class="line"><span class="lineno">  657</span>            taukappa =</div>
<div class="line"><span class="lineno">  658</span>                (<a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> + alpha_ * Delta_tau) * (<a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> + alpha_ * Delta_kappa);</div>
<div class="line"><span class="lineno">  659</span>            t0 = std::clamp(taukappa, mu_l, mu_u) - taukappa;</div>
<div class="line"><span class="lineno">  660</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> sum_correction =</div>
<div class="line"><span class="lineno">  661</span>                (t_xs.sum() + t_vw.sum() + t0) / (nv + nu + 1);</div>
<div class="line"><span class="lineno">  662</span>            t_xs.array() -= sum_correction;</div>
<div class="line"><span class="lineno">  663</span>            t_vw.array() -= sum_correction;</div>
<div class="line"><span class="lineno">  664</span>            t0 -= sum_correction;</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>            <span class="comment">// Save current directions before correction</span></div>
<div class="line"><span class="lineno">  667</span>            Delta_x_c = Delta_x;</div>
<div class="line"><span class="lineno">  668</span>            Delta_lambda_c = Delta_lambda;</div>
<div class="line"><span class="lineno">  669</span>            Delta_w_c = Delta_w;</div>
<div class="line"><span class="lineno">  670</span>            Delta_s_c = Delta_s;</div>
<div class="line"><span class="lineno">  671</span>            Delta_v_c = Delta_v;</div>
<div class="line"><span class="lineno">  672</span>            Delta_tau_c = Delta_tau;</div>
<div class="line"><span class="lineno">  673</span>            Delta_kappa_c = Delta_kappa;</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>            <span class="comment">// Solve correction system</span></div>
<div class="line"><span class="lineno">  676</span>            <a class="code hl_function" href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">solve_newton_system</a>(</div>
<div class="line"><span class="lineno">  677</span>                Delta_x_c, Delta_lambda_c, Delta_w_c, Delta_s_c, Delta_v_c,</div>
<div class="line"><span class="lineno">  678</span>                Delta_tau_c, Delta_kappa_c, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, b, c, ubi, ubv,</div>
<div class="line"><span class="lineno">  679</span>                delta_x, delta_y, delta_z, delta_0, x, lambda, w, s, v, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>,</div>
<div class="line"><span class="lineno">  680</span>                <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Eigen::VectorXd::Zero(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rp.size()),</div>
<div class="line"><span class="lineno">  681</span>                Eigen::VectorXd::Zero(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.ru.size()),</div>
<div class="line"><span class="lineno">  682</span>                Eigen::VectorXd::Zero(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rd.size()), 0, -t_xs, -t_vw, -t0);</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span>            alpha_c =</div>
<div class="line"><span class="lineno">  685</span>                <a class="code hl_function" href="#a16c38201e3fc179e9265a82e67510679">max_alpha</a>(x, Delta_x_c, v, Delta_v_c, s, Delta_s_c, w,</div>
<div class="line"><span class="lineno">  686</span>                          Delta_w_c, <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>, Delta_tau_c, <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>, Delta_kappa_c);</div>
<div class="line"><span class="lineno">  687</span>            <span class="keywordflow">if</span> (alpha_c &gt; alpha) {</div>
<div class="line"><span class="lineno">  688</span>                Delta_x = Delta_x_c;</div>
<div class="line"><span class="lineno">  689</span>                Delta_lambda = Delta_lambda_c;</div>
<div class="line"><span class="lineno">  690</span>                Delta_w = Delta_w_c;</div>
<div class="line"><span class="lineno">  691</span>                Delta_s = Delta_s_c;</div>
<div class="line"><span class="lineno">  692</span>                Delta_v = Delta_v_c;</div>
<div class="line"><span class="lineno">  693</span>                Delta_tau = Delta_tau_c;</div>
<div class="line"><span class="lineno">  694</span>                Delta_kappa = Delta_kappa_c;</div>
<div class="line"><span class="lineno">  695</span>                alpha = alpha_c;</div>
<div class="line"><span class="lineno">  696</span>            }</div>
<div class="line"><span class="lineno">  697</span>            <span class="keywordflow">if</span> (alpha_c &lt; 1.1 * alpha_) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  698</span>        }</div>
<div class="line"><span class="lineno">  699</span> </div>
<div class="line"><span class="lineno">  700</span>        <span class="comment">// Final update step (with slight back-off)</span></div>
<div class="line"><span class="lineno">  701</span>        alpha *= 0.9995;</div>
<div class="line"><span class="lineno">  702</span>        x += alpha * Delta_x;</div>
<div class="line"><span class="lineno">  703</span>        lambda += alpha * Delta_lambda;</div>
<div class="line"><span class="lineno">  704</span>        s += alpha * Delta_s;</div>
<div class="line"><span class="lineno">  705</span>        v += alpha * Delta_v;</div>
<div class="line"><span class="lineno">  706</span>        w += alpha * Delta_w;</div>
<div class="line"><span class="lineno">  707</span>        <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> += alpha * Delta_tau;</div>
<div class="line"><span class="lineno">  708</span>        <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> += alpha * Delta_kappa;</div>
<div class="line"><span class="lineno">  709</span>    }</div>
<div class="line"><span class="lineno">  710</span> </div>
<div class="line"><span class="lineno">  711</span>    <span class="comment">// Final solution recovery</span></div>
<div class="line"><span class="lineno">  712</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> inv_tau = 1.0 / <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>;</div>
<div class="line"><span class="lineno">  713</span>    Eigen::VectorXd original_x(As.cols());</div>
<div class="line"><span class="lineno">  714</span>    <span class="keywordtype">int</span> free_var = 0;</div>
<div class="line"><span class="lineno">  715</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; lo.size(); ++j) {</div>
<div class="line"><span class="lineno">  716</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> l = lo[j];</div>
<div class="line"><span class="lineno">  717</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> h = hi[j];</div>
<div class="line"><span class="lineno">  718</span>        <span class="keywordflow">if</span> (l == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; h == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  719</span>            original_x[j] = (x[j + free_var] - x[nv_orig + free_var]) * inv_tau;</div>
<div class="line"><span class="lineno">  720</span>            ++free_var;</div>
<div class="line"><span class="lineno">  721</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(l) &amp;&amp; std::isfinite(h)) {</div>
<div class="line"><span class="lineno">  722</span>            original_x[j] = l + x[j] * inv_tau;</div>
<div class="line"><span class="lineno">  723</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l == -<a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a> &amp;&amp; std::isfinite(h)) {</div>
<div class="line"><span class="lineno">  724</span>            original_x[j] = h - x[j] * inv_tau;</div>
<div class="line"><span class="lineno">  725</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::isfinite(l) &amp;&amp; h == <a class="code hl_variable" href="#a981ecfeb17af8eebcb536c8ec5075e28">infty</a>) {</div>
<div class="line"><span class="lineno">  726</span>            original_x[j] = l + x[j] * inv_tau;</div>
<div class="line"><span class="lineno">  727</span>        }</div>
<div class="line"><span class="lineno">  728</span>    }</div>
<div class="line"><span class="lineno">  729</span> </div>
<div class="line"><span class="lineno">  730</span>    <a class="code hl_variable" href="#a46689efc5c499d0e9b53b661e0a5405e">objVal</a> = cs.dot(original_x);</div>
<div class="line"><span class="lineno">  731</span>    lambda *= inv_tau;</div>
<div class="line"><span class="lineno">  732</span>    <a class="code hl_variable" href="#a8b689456be5e57ddcadae9254dc35c4a">dual_vals</a>.assign(lambda.data(), lambda.data() + lambda.size());</div>
<div class="line"><span class="lineno">  733</span>    <a class="code hl_variable" href="#a77a138d4376f21d730e110d0547af83b">primal_vals</a>.assign(original_x.data(),</div>
<div class="line"><span class="lineno">  734</span>                       original_x.data() + original_x.size());</div>
<div class="line"><span class="lineno">  735</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a10d79c906c9f170d975b9404e793a14e"><div class="ttname"><a href="#a10d79c906c9f170d975b9404e793a14e">IPSolver::solve_augsys</a></div><div class="ttdeci">void solve_augsys(Eigen::VectorXd &amp;delta_x, Eigen::VectorXd &amp;delta_y, Eigen::VectorXd &amp;delta_z, SparseSolver &amp;ls, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d, const Eigen::VectorXd &amp;xi_u)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00222">IPSolver.cpp:222</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a16c38201e3fc179e9265a82e67510679"><div class="ttname"><a href="#a16c38201e3fc179e9265a82e67510679">IPSolver::max_alpha</a></div><div class="ttdeci">double max_alpha(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;dx, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;dv, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;ds, const Eigen::VectorXd &amp;w, const Eigen::VectorXd &amp;dw, double tau, double dtau, double kappa, double dkappa)</div><div class="ttdoc">Computes the maximum step size (alpha) that can be taken along the direction of the search vectors.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00398">IPSolver.cpp:398</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a1f22b1985e02e839ff3b2791a0389865"><div class="ttname"><a href="#a1f22b1985e02e839ff3b2791a0389865">IPSolver::update_residuals</a></div><div class="ttdeci">void update_residuals(Residuals &amp;res, const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;lambda, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;v, const Eigen::VectorXd &amp;w, const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXi &amp;ubi, double tau, double kappa)</div><div class="ttdoc">Updates the residuals for the interior point method solver.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00146">IPSolver.cpp:146</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a22f7028c11d89b7986357f004f269924"><div class="ttname"><a href="#a22f7028c11d89b7986357f004f269924">IPSolver::update_linear_solver</a></div><div class="ttdeci">int update_linear_solver(SparseSolver &amp;ls, const Eigen::VectorXd &amp;theta, const Eigen::VectorXd &amp;regP, const Eigen::VectorXd &amp;regD)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00856">IPSolver.cpp:856</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a2651221065511beedd53613296aaddcb"><div class="ttname"><a href="#a2651221065511beedd53613296aaddcb">IPSolver::convert_to_standard_form</a></div><div class="ttdeci">void convert_to_standard_form(const Eigen::SparseMatrix&lt; double &gt; &amp;A, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, const Eigen::VectorXd &amp;sense, Eigen::SparseMatrix&lt; double &gt; &amp;As, Eigen::VectorXd &amp;bs, Eigen::VectorXd &amp;cs)</div><div class="ttdoc">Converts the given linear programming problem to its standard form.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00039">IPSolver.cpp:39</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a2f6983d42c0a0af7344a9c7f9b79cdfe"><div class="ttname"><a href="#a2f6983d42c0a0af7344a9c7f9b79cdfe">IPSolver::convertToOptimizationData</a></div><div class="ttdeci">OptimizationData convertToOptimizationData(const ModelData &amp;modelData)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00799">IPSolver.cpp:799</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a4c6e2a7694ec8befa9470e1aa4acf438"><div class="ttname"><a href="#a4c6e2a7694ec8befa9470e1aa4acf438">IPSolver::n_slacks</a></div><div class="ttdeci">int n_slacks</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00191">IPSolver.h:191</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a5c55da355d90e490435337a5427b3c0c"><div class="ttname"><a href="#a5c55da355d90e490435337a5427b3c0c">IPSolver::ls</a></div><div class="ttdeci">SparseSolver ls</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00177">IPSolver.h:177</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a6b9b941d7216d239af63eede001ab647"><div class="ttname"><a href="#a6b9b941d7216d239af63eede001ab647">IPSolver::warm_start</a></div><div class="ttdeci">bool warm_start</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00192">IPSolver.h:192</a></div></div>
<div class="ttc" id="aclassIPSolver_html_aac549fa9ef9fd8c98dc9262550a81f4d"><div class="ttname"><a href="#aac549fa9ef9fd8c98dc9262550a81f4d">IPSolver::start_linear_solver</a></div><div class="ttdeci">void start_linear_solver(SparseSolver &amp;ls, const Eigen::SparseMatrix&lt; double &gt; A)</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00886">IPSolver.cpp:886</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ac1a5e7d41b0f72ce616f99b03d4785a5"><div class="ttname"><a href="#ac1a5e7d41b0f72ce616f99b03d4785a5">IPSolver::tol</a></div><div class="ttdeci">double tol</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00178">IPSolver.h:178</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ac225cc4dcfe81ae25d3d59bdcb0b029f"><div class="ttname"><a href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">IPSolver::solve_newton_system</a></div><div class="ttdeci">void solve_newton_system(Eigen::VectorXd &amp;Delta_x, Eigen::VectorXd &amp;Delta_lambda, Eigen::VectorXd &amp;Delta_w, Eigen::VectorXd &amp;Delta_s, Eigen::VectorXd &amp;Delta_v, double &amp;Delta_tau, double &amp;Delta_kappa, SparseSolver &amp;ls, const Eigen::VectorXd &amp;theta_vw, const Eigen::VectorXd &amp;b, const Eigen::VectorXd &amp;c, const Eigen::VectorXi &amp;ubi, const Eigen::VectorXd &amp;ubv, const Eigen::VectorXd &amp;delta_x, const Eigen::VectorXd &amp;delta_y, const Eigen::VectorXd &amp;delta_w, double delta_0, const Eigen::VectorXd &amp;iter_x, const Eigen::VectorXd &amp;iter_lambda, const Eigen::VectorXd &amp;iter_w, const Eigen::VectorXd &amp;iter_s, const Eigen::VectorXd &amp;iter_v, double iter_tau, double iter_kappa, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_u, const Eigen::VectorXd &amp;xi_d, double xi_g, const Eigen::VectorXd &amp;xi_xs, const Eigen::VectorXd &amp;xi_vw, double xi_tau_kappa)</div><div class="ttdoc">Solves the Newton system for the interior point method.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00271">IPSolver.cpp:271</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ad0c2594ea4f46d9be99f18a27b34a7d8"><div class="ttname"><a href="#ad0c2594ea4f46d9be99f18a27b34a7d8">IPSolver::max_iter</a></div><div class="ttdeci">int max_iter</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00179">IPSolver.h:179</a></div></div>
<div class="ttc" id="aclassIPSolver_html_af1d4563c64b404dc1c6a973f9b899508"><div class="ttname"><a href="#af1d4563c64b404dc1c6a973f9b899508">IPSolver::n_slacks_old</a></div><div class="ttdeci">int n_slacks_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00190">IPSolver.h:190</a></div></div>
<div class="ttc" id="aclassIPSolver_html_af3536735b8f4efc21e11a83b8062f5f2"><div class="ttname"><a href="#af3536735b8f4efc21e11a83b8062f5f2">IPSolver::res</a></div><div class="ttdeci">Residuals res</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00176">IPSolver.h:176</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_acc02635739446925971f247ee90227ad_cgraph.png" border="0" usemap="#aclassIPSolver_acc02635739446925971f247ee90227ad_cgraph" alt=""/></div>
<map name="aclassIPSolver_acc02635739446925971f247ee90227ad_cgraph" id="aclassIPSolver_acc02635739446925971f247ee90227ad_cgraph">
<area shape="rect" title="Runs the optimization process on the given model data." alt="" coords="5,200,177,225"/>
<area shape="rect" href="classIPSolver.html#a2651221065511beedd53613296aaddcb" title="Converts the given linear programming problem to its standard form." alt="" coords="273,5,411,46"/>
<area shape="poly" title=" " alt="" coords="98,198,144,130,181,90,223,55,256,40,259,44,226,60,184,94,148,133,102,201"/>
<area shape="rect" href="classIPSolver.html#a2f6983d42c0a0af7344a9c7f9b79cdfe" title=" " alt="" coords="225,70,459,96"/>
<area shape="poly" title=" " alt="" coords="103,197,153,151,186,126,223,105,238,99,240,104,226,109,189,130,156,155,107,201"/>
<area shape="rect" href="classIPSolver.html#a16c38201e3fc179e9265a82e67510679" title="Computes the maximum step size (alpha) that can be taken along the direction of the search vectors." alt="" coords="272,120,412,145"/>
<area shape="poly" title=" " alt="" coords="126,196,224,162,273,147,275,152,225,167,128,201"/>
<area shape="rect" href="classIPSolver.html#a10d79c906c9f170d975b9404e793a14e" title=" " alt="" coords="517,202,673,228"/>
<area shape="poly" title=" " alt="" coords="177,207,225,206,459,206,501,207,501,212,459,211,225,211,177,212"/>
<area shape="rect" href="classIPSolver.html#ac225cc4dcfe81ae25d3d59bdcb0b029f" title="Solves the Newton system for the interior point method." alt="" coords="263,220,420,261"/>
<area shape="poly" title=" " alt="" coords="177,219,248,227,248,233,177,225"/>
<area shape="rect" href="classIPSolver.html#aac549fa9ef9fd8c98dc9262550a81f4d" title=" " alt="" coords="271,285,412,326"/>
<area shape="poly" title=" " alt="" coords="120,223,226,270,257,280,255,286,224,275,118,228"/>
<area shape="rect" href="classIPSolver.html#a22f7028c11d89b7986357f004f269924" title=" " alt="" coords="265,351,419,391"/>
<area shape="poly" title=" " alt="" coords="104,224,153,278,188,309,226,335,251,347,249,352,223,340,184,313,149,282,100,227"/>
<area shape="rect" href="classIPSolver.html#a1f22b1985e02e839ff3b2791a0389865" title="Updates the residuals for the interior point method solver." alt="" coords="254,416,430,441"/>
<area shape="poly" title=" " alt="" coords="100,224,116,260,143,309,180,359,202,382,226,401,241,409,239,414,223,405,198,385,176,362,138,311,111,263,95,227"/>
<area shape="rect" href="classIPSolver.html#add3037642e4e2090f62e90d9df5eee9f" title="Computes the maximum step size (alpha) for a single direction vector." alt="" coords="526,112,665,153"/>
<area shape="poly" title=" " alt="" coords="412,130,510,130,510,135,412,135"/>
<area shape="rect" href="classIPSolver.html#a55c0e0acdfb28b73b2387a610bf8fbd6" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="731,195,911,235"/>
<area shape="poly" title=" " alt="" coords="674,212,716,212,716,218,674,218"/>
<area shape="poly" title=" " alt="" coords="421,230,501,222,501,227,421,235"/>
<area shape="rect" href="classIPSolver.html#ad6ab576c321bd6a0506d9c5bf8362f1a" title="Converts a dense vector to a sparse diagonal matrix." alt="" coords="507,285,683,326"/>
<area shape="poly" title=" " alt="" coords="413,303,491,303,491,308,413,308"/>
</map>
</div>

</div>
</div>
<a id="a0ecea75d40171352fa5298be01d3d007" name="a0ecea75d40171352fa5298be01d3d007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecea75d40171352fa5298be01d3d007">&#9670;&#160;</a></span>save_interior_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::save_interior_solution </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00207">207</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  212</span>                                              {</div>
<div class="line"><span class="lineno">  213</span>        <a class="code hl_variable" href="#a120a3a2e1d4aa282ef28da6ca378d7bc">x_old</a> = x;</div>
<div class="line"><span class="lineno">  214</span>        <a class="code hl_variable" href="#ade64d46c893afea62c9c761d8c93991d">lambda_old</a> = lambda;</div>
<div class="line"><span class="lineno">  215</span>        <a class="code hl_variable" href="#ac9a3f9beb44ee2ba28b0d5cc8ea6edfb">s_old</a> = s;</div>
<div class="line"><span class="lineno">  216</span>        <a class="code hl_variable" href="#ab34388a63283d1d26ccd9b77f879c16b">v_old</a> = v;</div>
<div class="line"><span class="lineno">  217</span>        <a class="code hl_variable" href="#a31f8ae7257d8a77f3caa63b3de21588c">w_old</a> = w;</div>
<div class="line"><span class="lineno">  218</span>        <a class="code hl_variable" href="#a60db34cbbec5a679411c8ec9d25f2dcd">tau_old</a> = <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a>;</div>
<div class="line"><span class="lineno">  219</span>        <a class="code hl_variable" href="#afc64d7bec3101a6366409c58206d976d">kappa_old</a> = <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a>;</div>
<div class="line"><span class="lineno">  220</span>    }</div>
<div class="ttc" id="aclassIPSolver_html_a120a3a2e1d4aa282ef28da6ca378d7bc"><div class="ttname"><a href="#a120a3a2e1d4aa282ef28da6ca378d7bc">IPSolver::x_old</a></div><div class="ttdeci">Eigen::VectorXd x_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00183">IPSolver.h:183</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a31f8ae7257d8a77f3caa63b3de21588c"><div class="ttname"><a href="#a31f8ae7257d8a77f3caa63b3de21588c">IPSolver::w_old</a></div><div class="ttdeci">Eigen::VectorXd w_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00187">IPSolver.h:187</a></div></div>
<div class="ttc" id="aclassIPSolver_html_a60db34cbbec5a679411c8ec9d25f2dcd"><div class="ttname"><a href="#a60db34cbbec5a679411c8ec9d25f2dcd">IPSolver::tau_old</a></div><div class="ttdeci">double tau_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00188">IPSolver.h:188</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ab34388a63283d1d26ccd9b77f879c16b"><div class="ttname"><a href="#ab34388a63283d1d26ccd9b77f879c16b">IPSolver::v_old</a></div><div class="ttdeci">Eigen::VectorXd v_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00186">IPSolver.h:186</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"><div class="ttname"><a href="#ac9a3f9beb44ee2ba28b0d5cc8ea6edfb">IPSolver::s_old</a></div><div class="ttdeci">Eigen::VectorXd s_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00185">IPSolver.h:185</a></div></div>
<div class="ttc" id="aclassIPSolver_html_ade64d46c893afea62c9c761d8c93991d"><div class="ttname"><a href="#ade64d46c893afea62c9c761d8c93991d">IPSolver::lambda_old</a></div><div class="ttdeci">Eigen::VectorXd lambda_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00184">IPSolver.h:184</a></div></div>
<div class="ttc" id="aclassIPSolver_html_afc64d7bec3101a6366409c58206d976d"><div class="ttname"><a href="#afc64d7bec3101a6366409c58206d976d">IPSolver::kappa_old</a></div><div class="ttdeci">double kappa_old</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8h_source.html#l00189">IPSolver.h:189</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a55c0e0acdfb28b73b2387a610bf8fbd6" name="a55c0e0acdfb28b73b2387a610bf8fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c0e0acdfb28b73b2387a610bf8fbd6">&#9670;&#160;</a></span>solve_augmented_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::solve_augmented_system </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the augmented system for the given right-hand side vectors. </p>
<p>This function solves the augmented system using either the augmented approach or the regularized approach based on the preprocessor directive <code>AUGMENTED</code>. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00206">206</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  209</span>                                                                 {</div>
<div class="line"><span class="lineno">  210</span>    <span class="comment">// Set-up right-hand side with preserved order</span></div>
<div class="line"><span class="lineno">  211</span>    Eigen::VectorXd xi(xi_d.size() + xi_p.size());</div>
<div class="line"><span class="lineno">  212</span>    xi &lt;&lt; xi_d, xi_p;</div>
<div class="line"><span class="lineno">  213</span> </div>
<div class="line"><span class="lineno">  214</span>    <span class="comment">// Solve augmented system</span></div>
<div class="line"><span class="lineno">  215</span>    Eigen::VectorXd d = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.solve(xi);</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span>    <span class="comment">// Recover dx, dy in original order</span></div>
<div class="line"><span class="lineno">  218</span>    dx = d.head(xi_d.size());  <span class="comment">// Gets the first n elements</span></div>
<div class="line"><span class="lineno">  219</span>    dy = d.tail(xi_p.size());  <span class="comment">// Gets the last m elements</span></div>
<div class="line"><span class="lineno">  220</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a10d79c906c9f170d975b9404e793a14e" name="a10d79c906c9f170d975b9404e793a14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d79c906c9f170d975b9404e793a14e">&#9670;&#160;</a></span>solve_augsys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::solve_augsys </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>theta_vw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>ubi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_u</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00222">222</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  228</span>                                                       {</div>
<div class="line"><span class="lineno">  229</span>    <span class="comment">// Static allocation for frequently used vectors</span></div>
<div class="line"><span class="lineno">  230</span>    <span class="keyword">static</span> Eigen::VectorXd xi_d_mod;</div>
<div class="line"><span class="lineno">  231</span>    <span class="keywordflow">if</span> (xi_d_mod.size() != xi_d.size()) {</div>
<div class="line"><span class="lineno">  232</span>        xi_d_mod.resize(xi_d.size());</div>
<div class="line"><span class="lineno">  233</span>    }</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span>    <span class="comment">// Use direct memory copy instead of assignment</span></div>
<div class="line"><span class="lineno">  236</span>    std::memcpy(xi_d_mod.data(), xi_d.data(), xi_d.size() * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>    <span class="comment">// Get raw pointers for faster access</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="keywordtype">double</span> *xi_d_data = xi_d_mod.data();</div>
<div class="line"><span class="lineno">  240</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *theta_vw_data = theta_vw.data();</div>
<div class="line"><span class="lineno">  241</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *xi_u_data = xi_u.data();</div>
<div class="line"><span class="lineno">  242</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> *ubi_data = ubi.data();</div>
<div class="line"><span class="lineno">  243</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> ubi_size = ubi.size();</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi_size; ++i) {</div>
<div class="line"><span class="lineno">  246</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = ubi_data[i];</div>
<div class="line"><span class="lineno">  247</span>        xi_d_data[idx] -= xi_u_data[i] * theta_vw_data[i];</div>
<div class="line"><span class="lineno">  248</span>    }</div>
<div class="line"><span class="lineno">  249</span> </div>
<div class="line"><span class="lineno">  250</span>    <span class="comment">// Solve augmented system with optimized xi_d_mod</span></div>
<div class="line"><span class="lineno">  251</span>    <a class="code hl_function" href="#a55c0e0acdfb28b73b2387a610bf8fbd6">solve_augmented_system</a>(delta_x, delta_y, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, xi_p, xi_d_mod);</div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span>    <span class="comment">// Update delta_z efficiently</span></div>
<div class="line"><span class="lineno">  254</span>    delta_z.resize(ubi_size);</div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordtype">double</span> *delta_z_data = delta_z.data();</div>
<div class="line"><span class="lineno">  256</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *delta_x_data = delta_x.data();</div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi_size; ++i) {</div>
<div class="line"><span class="lineno">  259</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = ubi_data[i];</div>
<div class="line"><span class="lineno">  260</span>        delta_z_data[i] = (delta_x_data[idx] - xi_u_data[i]) * theta_vw_data[i];</div>
<div class="line"><span class="lineno">  261</span>    }</div>
<div class="line"><span class="lineno">  262</span>}</div>
<div class="ttc" id="aclassIPSolver_html_a55c0e0acdfb28b73b2387a610bf8fbd6"><div class="ttname"><a href="#a55c0e0acdfb28b73b2387a610bf8fbd6">IPSolver::solve_augmented_system</a></div><div class="ttdeci">void solve_augmented_system(Eigen::VectorXd &amp;dx, Eigen::VectorXd &amp;dy, SparseSolver &amp;ls, const Eigen::VectorXd &amp;xi_p, const Eigen::VectorXd &amp;xi_d)</div><div class="ttdoc">Solves the augmented system for the given right-hand side vectors.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00206">IPSolver.cpp:206</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph.png" border="0" usemap="#aclassIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph" alt=""/></div>
<map name="aclassIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph" id="aclassIPSolver_a10d79c906c9f170d975b9404e793a14e_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,162,38"/>
<area shape="rect" href="classIPSolver.html#a55c0e0acdfb28b73b2387a610bf8fbd6" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="210,5,389,46"/>
<area shape="poly" title=" " alt="" coords="162,23,194,23,194,28,162,28"/>
</map>
</div>

</div>
</div>
<a id="ac225cc4dcfe81ae25d3d59bdcb0b029f" name="ac225cc4dcfe81ae25d3d59bdcb0b029f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac225cc4dcfe81ae25d3d59bdcb0b029f">&#9670;&#160;</a></span>solve_newton_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::solve_newton_system </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>Delta_kappa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>theta_vw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>ubi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ubv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>delta_w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta_0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>iter_v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iter_tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iter_kappa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>xi_g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_xs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>xi_vw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>xi_tau_kappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Newton system for the interior point method. </p>
<p>This function updates the provided solution vectors (Delta_x, Delta_lambda, Delta_w, Delta_s, Delta_v) and scalars (Delta_tau, Delta_kappa) by solving the augmented system using the provided sparse solver. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00271">271</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>                         {</div>
<div class="line"><span class="lineno">  286</span>    Eigen::VectorXd xi_d_copy =</div>
<div class="line"><span class="lineno">  287</span>        xi_d - (xi_xs.array() / iter_x.array()).matrix();</div>
<div class="line"><span class="lineno">  288</span>    Eigen::VectorXd xi_u_copy =</div>
<div class="line"><span class="lineno">  289</span>        xi_u - (xi_vw.array() / iter_w.array()).matrix();</div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    <span class="comment">// Pre-compute frequently used values</span></div>
<div class="line"><span class="lineno">  292</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> inv_tau = 1.0 / iter_tau;</div>
<div class="line"><span class="lineno">  293</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> inv_kappa = 1.0 / iter_kappa;</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    <span class="comment">// Pre-allocate vectors to avoid reallocations</span></div>
<div class="line"><span class="lineno">  296</span>    <span class="keyword">static</span> Eigen::VectorXd xi_d_mod;</div>
<div class="line"><span class="lineno">  297</span>    <span class="keywordflow">if</span> (xi_d_mod.size() != xi_d.size()) {</div>
<div class="line"><span class="lineno">  298</span>        xi_d_mod.resize(xi_d.size());</div>
<div class="line"><span class="lineno">  299</span>    }</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>    <span class="comment">// Use vectorized operations for division</span></div>
<div class="line"><span class="lineno">  302</span>    {</div>
<div class="line"><span class="lineno">  303</span>        {</div>
<div class="line"><span class="lineno">  304</span>            <span class="comment">// Compute xi_d_mod = xi_d - xi_xs./iter_x efficiently</span></div>
<div class="line"><span class="lineno">  305</span>            xi_d_mod = xi_d.array() - (xi_xs.array() / iter_x.array());</div>
<div class="line"><span class="lineno">  306</span>        }</div>
<div class="line"><span class="lineno">  307</span>        {</div>
<div class="line"><span class="lineno">  308</span>            <span class="comment">// Pre-compute xi_u_copy = xi_u - xi_vw./iter_w</span></div>
<div class="line"><span class="lineno">  309</span>            Eigen::VectorXd xi_u_copy =</div>
<div class="line"><span class="lineno">  310</span>                xi_u - (xi_vw.array() / iter_w.array()).matrix();</div>
<div class="line"><span class="lineno">  311</span> </div>
<div class="line"><span class="lineno">  312</span>            <span class="comment">// Call solve_augsys with pre-computed values</span></div>
<div class="line"><span class="lineno">  313</span>            <a class="code hl_function" href="#a10d79c906c9f170d975b9404e793a14e">solve_augsys</a>(Delta_x, Delta_lambda, Delta_w, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>, theta_vw, ubi,</div>
<div class="line"><span class="lineno">  314</span>                         xi_p, xi_d_mod, xi_u_copy);</div>
<div class="line"><span class="lineno">  315</span>        }</div>
<div class="line"><span class="lineno">  316</span>    }</div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span>    <span class="comment">// Compute Delta_tau using efficient dot products</span></div>
<div class="line"><span class="lineno">  319</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> c_dot_Delta_x = c.dot(Delta_x);</div>
<div class="line"><span class="lineno">  320</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> b_dot_Delta_lambda = b.dot(Delta_lambda);</div>
<div class="line"><span class="lineno">  321</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> ubv_dot_Delta_w = ubv.dot(Delta_w);</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>    Delta_tau = (xi_g + xi_tau_kappa * inv_tau + c_dot_Delta_x -</div>
<div class="line"><span class="lineno">  324</span>                 b_dot_Delta_lambda + ubv_dot_Delta_w) /</div>
<div class="line"><span class="lineno">  325</span>                delta_0;</div>
<div class="line"><span class="lineno">  326</span>    Delta_kappa = (xi_tau_kappa - iter_kappa * Delta_tau) * inv_tau;</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>    <span class="comment">// Update vectors using vectorized operations</span></div>
<div class="line"><span class="lineno">  329</span>    {</div>
<div class="line"><span class="lineno">  330</span>        {</div>
<div class="line"><span class="lineno">  331</span>            Delta_x.array() += Delta_tau * delta_x.array();</div>
<div class="line"><span class="lineno">  332</span>            Delta_lambda.array() += Delta_tau * delta_y.array();</div>
<div class="line"><span class="lineno">  333</span>            Delta_w.array() += Delta_tau * delta_w.array();</div>
<div class="line"><span class="lineno">  334</span>        }</div>
<div class="line"><span class="lineno">  335</span>        {</div>
<div class="line"><span class="lineno">  336</span>            <span class="comment">// Compute Delta_s and Delta_v using vectorized operations</span></div>
<div class="line"><span class="lineno">  337</span>            Delta_s = (xi_xs.array() - iter_s.array() * Delta_x.array()) /</div>
<div class="line"><span class="lineno">  338</span>                      iter_x.array();</div>
<div class="line"><span class="lineno">  339</span>            Delta_v = (xi_vw.array() - iter_v.array() * Delta_w.array()) /</div>
<div class="line"><span class="lineno">  340</span>                      iter_w.array();</div>
<div class="line"><span class="lineno">  341</span>        }</div>
<div class="line"><span class="lineno">  342</span>    }</div>
<div class="line"><span class="lineno">  343</span>}</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph.png" border="0" usemap="#aclassIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph" alt=""/></div>
<map name="aclassIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph" id="aclassIPSolver_ac225cc4dcfe81ae25d3d59bdcb0b029f_cgraph">
<area shape="rect" title="Solves the Newton system for the interior point method." alt="" coords="5,5,163,46"/>
<area shape="rect" href="classIPSolver.html#a10d79c906c9f170d975b9404e793a14e" title=" " alt="" coords="211,13,367,38"/>
<area shape="poly" title=" " alt="" coords="163,23,195,23,195,28,163,28"/>
<area shape="rect" href="classIPSolver.html#a55c0e0acdfb28b73b2387a610bf8fbd6" title="Solves the augmented system for the given right&#45;hand side vectors." alt="" coords="415,5,594,46"/>
<area shape="poly" title=" " alt="" coords="367,23,399,23,399,28,367,28"/>
</map>
</div>

</div>
</div>
<a id="aac549fa9ef9fd8c98dc9262550a81f4d" name="aac549fa9ef9fd8c98dc9262550a81f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac549fa9ef9fd8c98dc9262550a81f4d">&#9670;&#160;</a></span>start_linear_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::start_linear_solver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the linear solver by initializing the necessary data structures and performing factorization. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00886">886</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  887</span>                                                                      {</div>
<div class="line"><span class="lineno">  888</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.A = A;</div>
<div class="line"><span class="lineno">  889</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.m = A.rows();</div>
<div class="line"><span class="lineno">  890</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n = A.cols();</div>
<div class="line"><span class="lineno">  891</span>    <span class="comment">// print ls.A size</span></div>
<div class="line"><span class="lineno">  892</span> </div>
<div class="line"><span class="lineno">  893</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.theta = Eigen::VectorXd::Ones(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n);</div>
<div class="line"><span class="lineno">  894</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.regP = Eigen::VectorXd::Ones(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n);</div>
<div class="line"><span class="lineno">  895</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.regD = Eigen::VectorXd::Ones(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.m);</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span>    Eigen::SparseMatrix&lt;double&gt; topRight = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.A.transpose();</div>
<div class="line"><span class="lineno">  898</span>    Eigen::SparseMatrix&lt;double&gt; bottomLeft = <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.A;</div>
<div class="line"><span class="lineno">  899</span>    Eigen::SparseMatrix&lt;double&gt; topLeft =</div>
<div class="line"><span class="lineno">  900</span>        <a class="code hl_function" href="#ad6ab576c321bd6a0506d9c5bf8362f1a">convertToSparseDiagonal</a>(-<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.theta - <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.regP);</div>
<div class="line"><span class="lineno">  901</span>    Eigen::SparseMatrix&lt;double&gt; bottomRight = <a class="code hl_function" href="#ad6ab576c321bd6a0506d9c5bf8362f1a">convertToSparseDiagonal</a>(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.regD);</div>
<div class="line"><span class="lineno">  902</span> </div>
<div class="line"><span class="lineno">  903</span>    <span class="comment">// S_ is known, reserve space for it</span></div>
<div class="line"><span class="lineno">  904</span>    Eigen::SparseMatrix&lt;double&gt; S_(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.m, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.m);</div>
<div class="line"><span class="lineno">  905</span> </div>
<div class="line"><span class="lineno">  906</span>    <span class="comment">// Reserving space for tripletList</span></div>
<div class="line"><span class="lineno">  907</span>    <span class="keywordtype">int</span> estimated_nonzeros =</div>
<div class="line"><span class="lineno">  908</span>        topLeft.nonZeros() + 2 * topRight.nonZeros() + bottomRight.nonZeros();</div>
<div class="line"><span class="lineno">  909</span>    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; tripletList;</div>
<div class="line"><span class="lineno">  910</span>    tripletList.reserve(estimated_nonzeros);</div>
<div class="line"><span class="lineno">  911</span> </div>
<div class="line"><span class="lineno">  912</span>    <span class="comment">// Insert topLeft, topRight, bottomLeft, bottomRight matrices</span></div>
<div class="line"><span class="lineno">  913</span>    <span class="keyword">auto</span> insertBlock = [&amp;](<span class="keyword">const</span> Eigen::SparseMatrix&lt;double&gt; &amp;block,</div>
<div class="line"><span class="lineno">  914</span>                           <span class="keywordtype">int</span> startRow, <span class="keywordtype">int</span> startCol) {</div>
<div class="line"><span class="lineno">  915</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; block.outerSize(); ++k) {</div>
<div class="line"><span class="lineno">  916</span>            <span class="keywordflow">for</span> (Eigen::SparseMatrix&lt;double&gt;::InnerIterator it(block, k); it;</div>
<div class="line"><span class="lineno">  917</span>                 ++it) {</div>
<div class="line"><span class="lineno">  918</span>                tripletList.emplace_back(it.row() + startRow,</div>
<div class="line"><span class="lineno">  919</span>                                         it.col() + startCol, it.value());</div>
<div class="line"><span class="lineno">  920</span>            }</div>
<div class="line"><span class="lineno">  921</span>        }</div>
<div class="line"><span class="lineno">  922</span>    };</div>
<div class="line"><span class="lineno">  923</span> </div>
<div class="line"><span class="lineno">  924</span>    insertBlock(topLeft, 0, 0);</div>
<div class="line"><span class="lineno">  925</span>    insertBlock(topRight, 0, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n);</div>
<div class="line"><span class="lineno">  926</span>    insertBlock(bottomLeft, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n, 0);</div>
<div class="line"><span class="lineno">  927</span>    insertBlock(bottomRight, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n, <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n);</div>
<div class="line"><span class="lineno">  928</span> </div>
<div class="line"><span class="lineno">  929</span>    <span class="comment">// Finally, set the values from the triplets</span></div>
<div class="line"><span class="lineno">  930</span>    S_.setFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="lineno">  931</span>    <span class="comment">// S_.makeCompressed();</span></div>
<div class="line"><span class="lineno">  932</span> </div>
<div class="line"><span class="lineno">  933</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.S = S_;</div>
<div class="line"><span class="lineno">  934</span>    <span class="comment">// Factorize</span></div>
<div class="line"><span class="lineno">  935</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.factorizeMatrix(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.S);</div>
<div class="line"><span class="lineno">  936</span>}</div>
<div class="ttc" id="aclassIPSolver_html_ad6ab576c321bd6a0506d9c5bf8362f1a"><div class="ttname"><a href="#ad6ab576c321bd6a0506d9c5bf8362f1a">IPSolver::convertToSparseDiagonal</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; double &gt; convertToSparseDiagonal(const Eigen::VectorXd &amp;vec)</div><div class="ttdoc">Converts a dense vector to a sparse diagonal matrix.</div><div class="ttdef"><b>Definition</b> <a href="IPSolver_8cpp_source.html#l00023">IPSolver.cpp:23</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph.png" border="0" usemap="#aclassIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph" alt=""/></div>
<map name="aclassIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph" id="aclassIPSolver_aac549fa9ef9fd8c98dc9262550a81f4d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,147,46"/>
<area shape="rect" href="classIPSolver.html#ad6ab576c321bd6a0506d9c5bf8362f1a" title="Converts a dense vector to a sparse diagonal matrix." alt="" coords="195,5,371,46"/>
<area shape="poly" title=" " alt="" coords="147,23,179,23,179,28,147,28"/>
</map>
</div>

</div>
</div>
<a id="a900ccac531085de01e8e3a60e2eca4bd" name="a900ccac531085de01e8e3a60e2eca4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900ccac531085de01e8e3a60e2eca4bd">&#9670;&#160;</a></span>unscale_solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::unscale_solution </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structScalingFactors.html">ScalingFactors</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22f7028c11d89b7986357f004f269924" name="a22f7028c11d89b7986357f004f269924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f7028c11d89b7986357f004f269924">&#9670;&#160;</a></span>update_linear_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::update_linear_solver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseSolver.html">SparseSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>regP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>regD</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00856">856</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  859</span>                                                              {</div>
<div class="line"><span class="lineno">  860</span>    <span class="comment">// Update internal data</span></div>
<div class="line"><span class="lineno">  861</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.theta = theta;</div>
<div class="line"><span class="lineno">  862</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.regP = regP;</div>
<div class="line"><span class="lineno">  863</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.regD = regD;</div>
<div class="line"><span class="lineno">  864</span> </div>
<div class="line"><span class="lineno">  865</span>    <span class="comment">// Update S. S is stored as upper-triangular and only its diagonal changes.</span></div>
<div class="line"><span class="lineno">  866</span>    Eigen::VectorXd combinedValues(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n + <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.m);</div>
<div class="line"><span class="lineno">  867</span>    combinedValues.head(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.n) = -theta - regP;</div>
<div class="line"><span class="lineno">  868</span>    combinedValues.tail(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.m) = regD;</div>
<div class="line"><span class="lineno">  869</span> </div>
<div class="line"><span class="lineno">  870</span>    <span class="comment">// Efficiently update diagonal elements</span></div>
<div class="line"><span class="lineno">  871</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; combinedValues.size(); i++) {</div>
<div class="line"><span class="lineno">  872</span>        <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.S.coeffRef(i, i) = combinedValues[i];</div>
<div class="line"><span class="lineno">  873</span>    }</div>
<div class="line"><span class="lineno">  874</span> </div>
<div class="line"><span class="lineno">  875</span>    <span class="comment">// Refactorize</span></div>
<div class="line"><span class="lineno">  876</span>    <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.factorizeMatrix(<a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.S);</div>
<div class="line"><span class="lineno">  877</span> </div>
<div class="line"><span class="lineno">  878</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#a5c55da355d90e490435337a5427b3c0c">ls</a>.info();</div>
<div class="line"><span class="lineno">  879</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f22b1985e02e839ff3b2791a0389865" name="a1f22b1985e02e839ff3b2791a0389865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f22b1985e02e839ff3b2791a0389865">&#9670;&#160;</a></span>update_residuals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPSolver::update_residuals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structResiduals.html">Residuals</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ubv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;</td>          <td class="paramname"><span class="paramname"><em>ubi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the residuals for the interior point method solver. </p>
<p>This function calculates and updates the primal residual (rp), upper bound residual (ru), dual residual (rd), and gap residual (rg) along with their norms. </p>

<p class="definition">Definition at line <a class="el" href="IPSolver_8cpp_source.html#l00146">146</a> of file <a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  152</span>                  {</div>
<div class="line"><span class="lineno">  153</span>    <span class="comment">// Pre-compute tau-scaled vectors to avoid repeated multiplications</span></div>
<div class="line"><span class="lineno">  154</span>    <span class="keyword">const</span> Eigen::VectorXd tau_b = <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * b;</div>
<div class="line"><span class="lineno">  155</span>    <span class="keyword">const</span> Eigen::VectorXd tau_c = <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * c;</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>    <span class="comment">// Calculate primal residual (rp)</span></div>
<div class="line"><span class="lineno">  158</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rp.noalias() = tau_b - A * x;</div>
<div class="line"><span class="lineno">  159</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rpn = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rp.norm();</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>    <span class="comment">// Update residual for upper bounds (ru)</span></div>
<div class="line"><span class="lineno">  162</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.ru = -v;  <span class="comment">// Direct assignment for better performance</span></div>
<div class="line"><span class="lineno">  163</span> </div>
<div class="line"><span class="lineno">  164</span>    <span class="comment">// Use raw pointers for faster access in the loop</span></div>
<div class="line"><span class="lineno">  165</span>    <span class="keywordtype">double</span> *ru_data = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.ru.data();</div>
<div class="line"><span class="lineno">  166</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *ubv_data = ubv.data();</div>
<div class="line"><span class="lineno">  167</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *x_data = x.data();</div>
<div class="line"><span class="lineno">  168</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> *ubi_data = ubi.data();</div>
<div class="line"><span class="lineno">  169</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> ubi_size = ubi.size();</div>
<div class="line"><span class="lineno">  170</span> </div>
<div class="line"><span class="lineno">  171</span>    <span class="comment">// Parallelize the loop for updating ru</span></div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi_size; ++i) {</div>
<div class="line"><span class="lineno">  173</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = ubi_data[i];</div>
<div class="line"><span class="lineno">  174</span>        ru_data[idx] += <a class="code hl_variable" href="#a54987d081f0eebc91d6a0247c471d92a">tau</a> * ubv_data[i] - x_data[idx];</div>
<div class="line"><span class="lineno">  175</span>    }</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>    <span class="comment">// Calculate dual residual (rd)</span></div>
<div class="line"><span class="lineno">  178</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rd.noalias() = tau_c - A.transpose() * lambda - s;</div>
<div class="line"><span class="lineno">  179</span> </div>
<div class="line"><span class="lineno">  180</span>    <span class="comment">// Update rd with w values</span></div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordtype">double</span> *rd_data = <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rd.data();</div>
<div class="line"><span class="lineno">  182</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> *w_data = w.data();</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>    <span class="comment">// Parallelize the loop for updating rd</span></div>
<div class="line"><span class="lineno">  185</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ubi_size; ++i) {</div>
<div class="line"><span class="lineno">  186</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = ubi_data[i];</div>
<div class="line"><span class="lineno">  187</span>        rd_data[idx] += w_data[i];</div>
<div class="line"><span class="lineno">  188</span>    }</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>    <span class="comment">// Calculate gap residual (rg) using dot products</span></div>
<div class="line"><span class="lineno">  191</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> cx = c.dot(x);</div>
<div class="line"><span class="lineno">  192</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> blambda = b.dot(lambda);</div>
<div class="line"><span class="lineno">  193</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> wubv = ubv.dot(w);</div>
<div class="line"><span class="lineno">  194</span> </div>
<div class="line"><span class="lineno">  195</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rg = <a class="code hl_variable" href="#a957045b153c2587ced811544b5772410">kappa</a> + cx - blambda + wubv;</div>
<div class="line"><span class="lineno">  196</span>    <a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rgn = std::abs(<a class="code hl_variable" href="#af3536735b8f4efc21e11a83b8062f5f2">res</a>.rg);</div>
<div class="line"><span class="lineno">  197</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b689456be5e57ddcadae9254dc35c4a" name="a8b689456be5e57ddcadae9254dc35c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b689456be5e57ddcadae9254dc35c4a">&#9670;&#160;</a></span>dual_vals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IPSolver::dual_vals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00194">194</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a981ecfeb17af8eebcb536c8ec5075e28" name="a981ecfeb17af8eebcb536c8ec5075e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981ecfeb17af8eebcb536c8ec5075e28">&#9670;&#160;</a></span>infty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::infty = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00180">180</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a957045b153c2587ced811544b5772410" name="a957045b153c2587ced811544b5772410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957045b153c2587ced811544b5772410">&#9670;&#160;</a></span>kappa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::kappa</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00178">178</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="afc64d7bec3101a6366409c58206d976d" name="afc64d7bec3101a6366409c58206d976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64d7bec3101a6366409c58206d976d">&#9670;&#160;</a></span>kappa_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::kappa_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00189">189</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ade64d46c893afea62c9c761d8c93991d" name="ade64d46c893afea62c9c761d8c93991d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade64d46c893afea62c9c761d8c93991d">&#9670;&#160;</a></span>lambda_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::lambda_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00184">184</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a5c55da355d90e490435337a5427b3c0c" name="a5c55da355d90e490435337a5427b3c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55da355d90e490435337a5427b3c0c">&#9670;&#160;</a></span>ls</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseSolver.html">SparseSolver</a> IPSolver::ls</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00177">177</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ad0c2594ea4f46d9be99f18a27b34a7d8" name="ad0c2594ea4f46d9be99f18a27b34a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c2594ea4f46d9be99f18a27b34a7d8">&#9670;&#160;</a></span>max_iter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::max_iter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00179">179</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a4c6e2a7694ec8befa9470e1aa4acf438" name="a4c6e2a7694ec8befa9470e1aa4acf438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6e2a7694ec8befa9470e1aa4acf438">&#9670;&#160;</a></span>n_slacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::n_slacks = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00191">191</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="af1d4563c64b404dc1c6a973f9b899508" name="af1d4563c64b404dc1c6a973f9b899508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d4563c64b404dc1c6a973f9b899508">&#9670;&#160;</a></span>n_slacks_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IPSolver::n_slacks_old = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00190">190</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a46689efc5c499d0e9b53b661e0a5405e" name="a46689efc5c499d0e9b53b661e0a5405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46689efc5c499d0e9b53b661e0a5405e">&#9670;&#160;</a></span>objVal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::objVal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00196">196</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a77a138d4376f21d730e110d0547af83b" name="a77a138d4376f21d730e110d0547af83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a138d4376f21d730e110d0547af83b">&#9670;&#160;</a></span>primal_vals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; IPSolver::primal_vals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00195">195</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="af3536735b8f4efc21e11a83b8062f5f2" name="af3536735b8f4efc21e11a83b8062f5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3536735b8f4efc21e11a83b8062f5f2">&#9670;&#160;</a></span>res</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structResiduals.html">Residuals</a> IPSolver::res</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00176">176</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ac9a3f9beb44ee2ba28b0d5cc8ea6edfb" name="ac9a3f9beb44ee2ba28b0d5cc8ea6edfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a3f9beb44ee2ba28b0d5cc8ea6edfb">&#9670;&#160;</a></span>s_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::s_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00185">185</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a54987d081f0eebc91d6a0247c471d92a" name="a54987d081f0eebc91d6a0247c471d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54987d081f0eebc91d6a0247c471d92a">&#9670;&#160;</a></span>tau</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::tau</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00178">178</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a60db34cbbec5a679411c8ec9d25f2dcd" name="a60db34cbbec5a679411c8ec9d25f2dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60db34cbbec5a679411c8ec9d25f2dcd">&#9670;&#160;</a></span>tau_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::tau_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00188">188</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ac1a5e7d41b0f72ce616f99b03d4785a5" name="ac1a5e7d41b0f72ce616f99b03d4785a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a5e7d41b0f72ce616f99b03d4785a5">&#9670;&#160;</a></span>tol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IPSolver::tol</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00178">178</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="ab34388a63283d1d26ccd9b77f879c16b" name="ab34388a63283d1d26ccd9b77f879c16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34388a63283d1d26ccd9b77f879c16b">&#9670;&#160;</a></span>v_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::v_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00186">186</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a31f8ae7257d8a77f3caa63b3de21588c" name="a31f8ae7257d8a77f3caa63b3de21588c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f8ae7257d8a77f3caa63b3de21588c">&#9670;&#160;</a></span>w_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::w_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00187">187</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a6b9b941d7216d239af63eede001ab647" name="a6b9b941d7216d239af63eede001ab647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9b941d7216d239af63eede001ab647">&#9670;&#160;</a></span>warm_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPSolver::warm_start = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00192">192</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<a id="a120a3a2e1d4aa282ef28da6ca378d7bc" name="a120a3a2e1d4aa282ef28da6ca378d7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120a3a2e1d4aa282ef28da6ca378d7bc">&#9670;&#160;</a></span>x_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd IPSolver::x_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IPSolver_8h_source.html#l00183">183</a> of file <a class="el" href="IPSolver_8h_source.html">IPSolver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="IPSolver_8h_source.html">IPSolver.h</a></li>
<li><a class="el" href="IPSolver_8cpp_source.html">IPSolver.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classIPSolver.html">IPSolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
